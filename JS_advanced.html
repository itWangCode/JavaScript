<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <link rel="stylesheet" href="">
</head>
<body>

</body>
<script type="text/javascript">
    /*==================================创建对象的三种方式===================================*/
    /*

       //对象：特值的某个事物，具有属性和方法（一组无序的属性的集合）
        //特征---》属性
        //行为---》方法
        //小汪--》姓名,性别，年龄，吃，睡觉，玩

        //创建对象三种方式：
    //    1.字面量的
    //    2.调用系统的构造函数
    //    3.自定义构造函数方式


        //字面量
        var per1 = {
           name:"xixi",
           age:20,
            sex:"男",
             eat:function () {
                 console.log("吃饭");
             },
            readBook:function () {
                console.log("散文诗歌");
            }
        };

        //调用系统函数的构造函数
        var per2 = new Object();
        per2.name = "haha";
        per2.age = 18;
        per2.sex = function () {
            console.log("吃榴莲")
        };
        per2.play = function () {
            console.log("真好玩")
        };
        function Person(){

        }
        //console.log(per2 instanceof Person)
        console.log(per2 instanceof Object);


    //自定义构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;

            this.play = function () {
                console.log("好玩");
            };
        }
        var per =  new Person("汪程序员",19,"女");
        console.log(per instanceof Person);
        console.log(per);
     */

    /*==================================自定义构造函数创建对象做的事情================================================*/
    /*


        function Person(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.play = function () {
            console.log("跑步");
        };
    }
    //创建对象---》实例化一个对象的同时对属性进行初始化
    var per = new Person("小汪",18,"男");
    console.log(per);

*/
    /*
    * 1.开辟空间存储对象
    * 2.把this设置当前的对象
    * 3.设置属性和方法的值
    * 4.把this对象返回
    * */
    /*============================工厂模式=====================================*/
    /*

        // 工厂模式创建对象
    function createObject(name,age) {
        var  obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.sayHi = function () {
            console.log("你好");
        };
        return obj;
    }

    var per = createObject("小汪",19);
    console.log(per);
     */


    /*
    *  自定义构造函数与工厂模式
    *  共同点：都是函数，都可以创建对象，都可以传入参数
    *
    *  工厂模式：函数名是小写,
    *           有new，有返回值
    *           new之后对象是当前的对象
    *           直接调用函数就可以创建对象
    *
    *
    *  自定义构造函数：函数名首字母是大写的，
    *               没有new，没有返回值
    *               this是当前的对象
    *               通过new的方式创建对象的
    *
    *
    * */


    /*=======================构造函数和实例对象之间的关系=======================================*/
    /*

       //面向对象的思想是------抽象的过程----实例化的过程
        //我这个人：姓名，年龄，性别，吃饭，打招呼，睡觉。。。
        //自定义构造函数---实例化对象
        //这是构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.sayHi = function () {
                console.log("hello");
            };
            this.sleep = function () {
                console.log("sleep")
            };
            this.eat = function () {
                console.log("吃");
            }
        }//构造函数end


        //构造函数---》创建对象
        var per = new Person("汪洋",28,"男");
        per.eat();
        //实例对象是通过构造函数来创建
        //实例对象会指向自己的构造函数（暂时理解，是错误的）


        console.dir(per);//把这个对象的结构显示出来
        console.dir(Person);
        //实例对象的构造器是指向Person的，结构是true，所以，这个实例对象per就是通过Person来创建的
        console.log(per.constructor==Person);//true   //实例对象的构造器（构造函数）
        console.log(per.__proto__.constructor==Person);//true
        console.log(per.__proto__.constructor == Person.prototype.constructor);//true

        //构造函数
        function Animal(name) {
            this.name = name;
        }
        //实例对象
        var dog = new Animal("大黄");
        console.dir(dog);//实例对象
        console.dir(Animal);//构造函数的名字

        console.log(dog.__proto__.constructor == Person);//false
        console.log(dog.__proto__.constructor == Animal);//true

        //判断这个是不是这种数据类型
        console.log(dog.constructor==Animal);
        console.log(dog instanceof Person);
     */

    //总结：
    /**
     * 实例对象和构造函数之间的关系
     * 1.实例对象是通过 构造函数来创建的----创建的构成叫实例化
     * 2.如何判断对象是不是这个数据类型
     *   1）通过构造器的方式实例对象，构造器==构造函数名字
     *   2）对象instanceof构造函数名字
     *   尽可能使用 第二种方式来识别，为什么？原型讲完就明白了
     *
     *
     */
    /*=============================原型引入==================================*/
    //数据共享，节省内存空间，作用之一
    /*
    function Person(name,age) {
        this.name = name;
        this.age = age;
        this.eat = function () {
            console.log("吃肉");
        }
    }
    var per1 = new Person("小白",20);
    var per2 = new Person("小黑",22);
    per1.eat();
    per2.eat();
    //不是同一个方法
    console.log(per1.eat == per2.eat);//false,这两个不是同一个对象，也不是调用同一个方法

    console.dir(per1);
    console.log(per2);
*/

    /*
    function myEat() {
        console.log("吃肉");
    }

    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.eat = myEat;
    }

    var per1 = new Person("小白", 20);
    var per2 = new Person("小黑", 22);
    per1.eat();
    per2.eat();

    console.log(per1.eat == per2.eat);//true

      //实例对象中根本没有eat方法，但是能够使用，这是为什么呢？
    //window是对象
    //document是属性，document也是一个对象
    //write()是方法
    //window.document.write("哈哈");
    //对象.style.color=值;

    */

    /**
     *  原型？
     *  实例对象中有__proto__这个属性，叫原型，也是一个对象，这个属性是给浏览器使用的，不是标准属性
     *  构造函数中有prototype这个属性，叫做原型，也是一个对象,这个属性，是给程序员用的，是标准的属性----》prototype---》可以叫做原型对象
     *  实例对象的__proto__和构造函数中的prototype相等 ---》true
     *  有因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype
     *  实例对象的__proto__指向了构造函数的原型对象prototype
     *
     *
     */

    /*=======================================体会面向过程和面向对象思想编程============================================*/
    /*

        <style>
        #dv {
            width: 200px;
            height: 300px;
            background-color: red;
        }
    </style>

</head>
<body>
<input type="button" value="显示效果" id="btn">
<div id="dv"></div>

    //点击按钮，改变div的背景颜色

    //面向过程
    // my$("btn").onclick = function () {
    //     my$("dv").style.backgroundColor = "yellow";
    // };

       // function Person() {
    //     this.sayHi = function () {
    //         console.log(this);
    //     };
    // }
    // var per  = new Person();
    // per.sayHi();


     */

    /*    //面向对象写法：---初级
    //按钮是一个对象，div是一个对象，颜色是一个属性
    function ChangeStyle(btnId, dvId, color) {
        this.btnObj = my$(btnId);//按钮对象
        this.dvObj = my$(dvId);//div的对象
        this.color = color;//颜色
    }

    //数据共享来改变背景颜色
    ChangeStyle.prototype.init = function () {
        //console.log(this);//就是实例对象--当前对象
        var that = this;
        this.btnObj.onclick = function () {
            that.dvObj.style.backgroundColor = that.color;
        }
    };

    //实例化对象
    var cs = new ChangeStyle("btn", "dv", "yellow");
    cs.init();


    //❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️
      //面向对象写法：---高级
    function ChangeStyle(btnObj, dvObj, json) {
        this.btnObj = btnObj;
        this.dvObj = dvObj;
        this.json = json;
    }
    ChangeStyle.prototype.init = function () {
        //点击按钮，改变div对个样式属性
        var that = this;
        this.btnObj.onclick = function () {//按钮
            for (var key in that.json){
                that.dvObj.style[key] = that.json[key];
            }
        }
    };
    //实例化对象
    var json = {"width":"500px","height":"800px","backgroundColor":"yellow"};
    var cs = new ChangeStyle(my$("btn"),my$("dv"),json);
    cs.init();//调用方法

*/

    /*============================复习原型==============================*/
    /*
       //构造函数
       function Person(name,age) {
           this.name = name;
           this.age = age;
       }
       //通过原型增加方法
        Person.prototype.sayHi = function () {
            console.log("hey");
        };
        var per = new Person("小明",20);
        console.dir(per);
        console.dir(Person);

        var per2 = new Person("女",20);
        console.log(per.sayHi == per2.sayHi);//true

        //实例对象中，有两个属性（这两个属性是通过构造函数来获取的），__proto__这个属性
        //构造函数中并没有sex和age的两个属性
     */

    /**
     * 实例对象中有个属性__proto__，也是对象，叫原型，不是标准的属性，浏览器使用的
     * 构造函数中有一个属性，prototype,也是对象，叫原型，程序员用的
     * 原型----》__proto__或者是prototype，都是原型对象
     * 原型的作用：共享数据，节省内存空间
     *
     */

    /*============================构造函数和实例对象和原型对象的关系================================*/

    /*


        //荣光构造函数实例对象，并且初始化
        var arr = new Array(10,20,30,40);
        //var per = new Person("小明",20,"男");
        //join是方法，实例对象调用的方法
        arr.join("|");
        console.log(arr);
        //join方法在实例对象__proto__原型中
         console.log(arr.__proto__ == Array.prototype);//true

        //构造函数
        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }

        //通过构造函数的原型增加一个方法
        Person.prototype.eat = function () {
            console.log("吃饭");
        };
        var per = new Person(20,"男");
        per.eat();

        //构造函数和原型对象和实例对象的关系
        console.dir(Person);
        console.dir(per);
     */
    /**
     * 1.通过构造函数创建实例对象
     * 2.原型在构造函数里面
     * 3.实例对象可以调用方法
     */


    /*======================总结三者之间的关系=============================*/

    //总结三种的关系

    /**
     * 构造函数可以实例化对象
     * 构造函数中有一个函数叫prototype，是构造函数的原型对象、
     * 构造函数的原型对象（prototype）中有一个constructor构造器，这个构造器指向的就是自己所在的原型对象所在的构造函数
     * 实例对象的原型对象（__proto__）指向的是该构造的原型对象
     * 构造函数的原型对象（prototype）中的方法是可以被实例对象直接访问
     *
     *
     */
    /*===========================利用原型共享数据======================================*/
    /*

        //什么样的额数据是需要写在原型中？
    //需要共享的数据就可以写在原型中
    //原型的作用之一：数据共享

    //属性需要共享，方法也需要共享，写在原型中
    //不需要共享的带哦你关系，写在构造函数中

    //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //所有学生的身高188，所有的体重都是55
    //所有的学生每天都要写500行代码
    //所有的学生每天都要吃10斤西瓜
    //原型对象
    Student.prototype.height = "188cm";
    Student.prototype.weight = "55kg";
    Student.prototype.coding = function () {
        console.log("敲代码。500行");
    };
    Student.prototype.eat = function () {
        console.log("吃10斤西瓜");
    };

    //实例化对象，并且初始化
    var stu = new Student("小明",20,"男");
    console.dir(Student);
    console.dir(stu);//方法在__proto__中
    stu.coding();
    stu.eat();


     */

    /*===========================原型的简单语法===================================*/
    /*

        //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //简单的原型写法
    Student.prototype = {
        //手动修改构造器的指向
        constructor:Student,
        height:"188cm",
        weight :"55kg",
        study : function () {
            console.log("学习好开心呀");
        },
        eat : function () {
            console.log("吃饭啦");
        }
    };

    var stu  = new Student("小明",20,"男");
    console.dir(Student);//原型对象
    console.dir(stu);//实例对象
    stu.study();
    stu.eat();




     */

    /*==========================原型中的方法是可以相互访问的==============================*/

    /*    function Person(age) {
            this.age = age;
            this.sayHi = function () {
                console.log("hey");
                //打招呼的同时，直接调用吃的方法
                // this.eat();
            };
            this.eat = function () {
                console.log("吃饭");
                this.sayHi();
            };
        }
        //实例化对象。并且初始化
        var per = new Person(20);
        //调用方法

        //per.sayHi();
        per.eat();

        //实例对象的方法是可以相互调用的*/

    /*
        //原型中的方法是可以相互访问的
        function Animal(name,age) {
            this.name = name;
            this.age = age;
        }
        //原型中添加方法
        Animal.prototype.eat = function () {
            console.log("动物吃东西");
            this.play();
        };
        Animal.prototype.play = function () {
            console.log("玩球");
            this.sleep();
        };
        Animal.prototype.sleep = function () {
            console.log("睡觉");
        };

        var dog = new Animal("小汪",20,"男");
        dog.eat();
        //原型对象中的方法，是可以相互调用的
    */

    /*=======================实例对象使用的属性和方法层层的搜索========================================*/
    /*


        function Person(age,sex) {
        this.age = age;//年龄
        this.sex = sex;//性别
        this.eat = function () {
            console.log("构造函数中的吃");
        };
    }
    Person.prototype.sex = "女";
    Person.prototype.eat = function () {
      console.log("原型对象吃大餐");
    };
    var per  = new Person(20,"男");
    console.log(per.sex);
    per.eat();
    console.dir(Person);
    console.log(per);
    //先从实例化对象中去找，如果实例对象中部存在，就会在原型中去找


     */

    /*

        实例对象使用的属性或者方法，现在实例中查找，找到了则直接使用，找不到则去实例对象的__proto__指向的原型对象prototype中找，找到了则使用，找不到就会报错

     */


    /*=========================为内置对象的原型对象中添加方法======================================*/
    /*

        //为内置对象增加原型对象方法
    var arr = new Array(10,20,30,40);
    arr.join("|");
    console.log(arr);
    console.dir(arr);

    var str = new String("哦，哈哈");
    str.indexOf("哦");
    console.dir(str);
    //实例中的方法如果没有，去创建改实例对象的构造函数的原型对象中找


    //我们能否为系统的对象的原型中增加方法，相当于改变源码
    //我希望字符串中有一个倒序的这个方法
    String.prototype.myReverse = function () {
        for (var i = this.length-1; i >= 0; i--){
            console.log(this[i])
        }
    };
    var str = "abcdefg";
    str.myReverse();


    //为Array内置对象的原型对象中增加方法
    Array.prototype.mySort = function () {
        for (var i = 0; i <this.length- 1; i++){
            for(var j = 0; j < this.length - 1; j++){
                if (this[j] < this[j+1]){
                    var temp = this[j];
                    this[j] = this [j +1];
                    this[j+1]=temp;
                }
            }
        }
    };
    var arr = [100,20,30,4056,30,20];
    arr.mySort();
    console.log(arr);


    String.prototype.sayHi = function () {
        console.log(this+"哈哈，我又变帅了");
    };
    //字符串就有了打招呼的方法了
    var str2 = "小样";
    str2.sayHi();


     */

    /*========================局部变量变成全局变量==================================*/

    /*

        //该函数的自调用
    //一次性的函数，声明的同时，直接调用了
    //页面加载后，这个自调用函数代码，就执行完了
    // (function (形参) {
    //     var num = 10;
    //     console.log(num);
    // })(实参);
    // console.log(num);//报错


    (function (win) {
        var num = 10;
        //js是一门动态类型的语言，对象没有属性，点了就有了
        win.number = num;
    })(window);

    console.log(number);//10


    //如何把局部变量编程全局
    //把局部变量给window就可以了

     */


    /*=====================产生随机数对象==============================================*/

    /*
   //通过自调用函数产生一个随机数对象，在自调用函数外面，调用改随机数对象方法产生随机数

    (function (window) {
        //产生随机数的构造函数
        function Random() {

        }
        //在原型对象中添加方法
        Random.prototype.getRandom = function (min,max) {
            return Math.floor(Math.random()*(max-min)+min);//0-4
        };

        // var rm = new Random();
        // var num = rm.getRandom();
        // console.log(num);

        window.Random = Random;

    })(window);

    console.log(window.Random);
    var rm =new Random();
    console.log(rm.getRandom(10,50));

     */

    /*======================随机小方块=======================================*/
    /*

            .map {
                width: 800px;
                height: 600px;
                background-color: #d3d3d3;
                position: relative;
            }

        </style>
    </head>
    <body>

    <div class="map">
        <div class="minBox"></div>
    </div>


        //自调用构造函数的方式，分号一定要加上

        //产生随机数的对象
        (function (window) {
            function Random() {

            }

            //在原型对象中增加方法
            Random.prototype.gegRandom = function (min, max) {
                return Math.floor(Math.random() * (max - min) + min);
            };
            //吧局部对象暴露给window顶级对象，就成了全局变量对象
            window.Random =new Random;
        })(window);

        console.log(Random.gegRandom(0,5));
        //产生小方块对象
        (function (window) {
            //选择器的方式来获取元素对象
            var map = document.querySelector(".map");
            //食物的构造函数对象
            function Food(width,height,color) {
                this.width = width || 20;//默认小方块的宽
                this.height = height || 20;
                this.color = color;
                this.x = 0;
                this.y = 0;
                this.element = document.createElement("div");//小方块元素
            }
            //初始化小方块的显示效果及位置---显示地图上面
            Food.prototype.init = function (map) {
                //设置小方块的样式
                var div = this.element;
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height =this.height + "px";
                div.style.backgroundColor = this.color;
                map.appendChild(div);//吧小方块加到map中
                this.render(map);
            };
            //产生随机位置
            Food.prototype.render = function (map) {
                //随机产生横纵坐标
                var x = Random.gegRandom(0,map.offsetWidth/this.width)*this.width;
                var y = Random.gegRandom(0,map.offsetHeight/this.height)*this.height;
                this.x = x;
                this.y = y;
                var div = this.element;
                div.style.left = this.x + "px";
                div.style.top = this.y + "px";

            };

            var fd = new Food(20,20,"green");
            fd.init(map);
        })(window);

     */

    /*============================贪吃蛇=====================================*/
    /*

     <style>
        .map {
            width: 800px;
            height: 600px;
            background-color: #CCC;
            position: relative;
        }
    </style>
</head>
<body>
<!--画出地图,设置样式-->
<div class="map"></div>
<script>


    //自调用函数----食物的
    (function () {
        var elements = [];//用来保存每个小方块食物的
        //食物就是一个对象,有宽,有高,有颜色,有横纵坐标,先定义构造函数,然后创建对象
        function Food(x, y, width, height, color) {
            //横纵坐标
            this.x = x || 0;
            this.y = y || 0;
            //宽和高
            this.width = width || 20;
            this.height = height || 20;
            //背景颜色
            this.color = color || "green";
        }

        //为原型添加初始化的方法(作用：在页面上显示这个食物)
        //因为食物要在地图上显示,所以,需要地图的这个参数(map---就是页面上的.class=map的这个div)
        Food.prototype.init = function (map) {
            //先删除这个小食物
            //外部无法访问的函数
            remove();

            //创建div
            var div = document.createElement("div");
            //把div加到map中
            map.appendChild(div);
            //设置div的样式
            div.style.width = this.width + "px";
            div.style.height = this.height + "px";
            div.style.backgroundColor = this.color;
            //先脱离文档流
            div.style.position = "absolute";
            //随机横纵坐标
            this.x = parseInt(Math.random() * (map.offsetWidth / this.width)) * this.width;
            this.y = parseInt(Math.random() * (map.offsetHeight / this.height)) * this.height;
            div.style.left = this.x + "px";
            div.style.top = this.y + "px";

            //把div加入到数组elements中
            elements.push(div);
        };

        //私有的函数---删除食物的
        function remove() {
            //elements数组中有这个食物
            for (var i = 0; i < elements.length; i++) {
                var ele = elements[i];
                //找到这个子元素的父级元素,然后删除这个子元素
                ele.parentNode.removeChild(ele);
                //再次把elements中的这个子元素也要删除
                elements.splice(i, 1);
            }
        }

        //把Food暴露给Window,外部可以使用
        window.Food = Food;
    }());

    //自调用函数---小蛇
    (function () {
        var elements = [];//存放小蛇的每个身体部分
        //小蛇的构造函数
        function Snake(width, height, direction) {
            //小蛇的每个部分的宽
            this.width = width || 20;
            this.height = height || 20;
            //小蛇的身体
            this.body = [
                {x: 3, y: 2, color: "red"},//头
                {x: 2, y: 2, color: "orange"},//身体
                {x: 1, y: 2, color: "orange"}//身体
            ];
            //方向
            this.direction = direction || "right";
        }

        //为原型添加方法--小蛇初始化的方法
        Snake.prototype.init = function (map) {
            //先删除之前的小蛇
            remove();//===========================================

            //循环遍历创建div
            for (var i = 0; i < this.body.length; i++) {
                //数组中的每个数组元素都是一个对象
                var obj = this.body[i];
                //创建div
                var div = document.createElement("div");
                //把div加入到map地图中
                map.appendChild(div);
                //设置div的样式
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height = this.height + "px";
                //横纵坐标
                div.style.left = obj.x * this.width + "px";
                div.style.top = obj.y * this.height + "px";
                //背景颜色
                div.style.backgroundColor = obj.color;
                //方向暂时不定
                //把div加入到elements数组中----目的是为了删除
                elements.push(div);
            }
        };

        //为原型添加方法---小蛇动起来
        Snake.prototype.move = function (food, map) {
            //改变小蛇的身体的坐标位置
            var i = this.body.length - 1;//2
            for (; i > 0; i--) {
                this.body[i].x = this.body[i - 1].x;
                this.body[i].y = this.body[i - 1].y;
            }
            //判断方向---改变小蛇的头的坐标位置
            switch (this.direction) {
                case "right":
                    this.body[0].x += 1;
                    break;
                case "left":
                    this.body[0].x -= 1;
                    break;
                case "top":
                    this.body[0].y -= 1;
                    break;
                case "bottom":
                    this.body[0].y += 1;
                    break;
            }

            //判断有没有吃到食物
            //小蛇的头的坐标和食物的坐标一致
            var headX=this.body[0].x*this.width;
            var headY=this.body[0].y*this.height;
            //判断小蛇的头的坐标和食物的坐标是否相同
            if(headX==food.x&&headY==food.y){
                //获取小蛇的最后的尾巴
                var last=this.body[this.body.length-1];
                //把最后的蛇尾复制一个,重新的加入到小蛇的body中
                this.body.push({
                    x:last.x,
                    y:last.y,
                    color:last.color
                });
                //把食物删除,重新初始化食物
                food.init(map);
            }
        }
        ;//删除小蛇的私有的函数=============================================================================
        function remove() {
            //删除map中的小蛇的每个div,同时删除elements数组中的每个元素,从蛇尾向蛇头方向删除div
            var i = elements.length - 1;
            for (; i >= 0; i--) {
                //先从当前的子元素中找到该子元素的父级元素,然后再弄死这个子元素
                var ele = elements[i];
                //从map地图上删除这个子元素div
                ele.parentNode.removeChild(ele);
                elements.splice(i, 1);
            }
        }

        //把Snake暴露给window,外部可以访问
        window.Snake = Snake;
    }());

    //自调用函数---游戏对象================================================
    (function () {

        var that = null;//该变量的目的就是为了保存游戏Game的实例对象-------

        //游戏的构造函数
        function Game(map) {
            this.food = new Food();//食物对象
            this.snake = new Snake();//小蛇对象
            this.map = map;//地图
            that = this;//保存当前的实例对象到that变量中-----------------此时that就是this
        }

        //初始化游戏-----可以设置小蛇和食物显示出来
        Game.prototype.init = function () {
            //初始化游戏
            //食物初始化
            this.food.init(this.map);
            //小蛇初始化
            this.snake.init(this.map);
            //调用自动移动小蛇的方法========================||调用了小蛇自动移动的方法
            this.runSnake(this.food, this.map);
            //调用按键的方法
            this.bindKey();//========================================
        };

        //添加原型方法---设置小蛇可以自动的跑起来
        Game.prototype.runSnake = function (food, map) {

            //自动的去移动
            var timeId = setInterval(function () {
                //此时的this是window
                //移动小蛇
                this.snake.move(food, map);
                //初始化小蛇
                this.snake.init(map);
                //横坐标的最大值
                var maxX = map.offsetWidth / this.snake.width;
                //纵坐标的最大值
                var maxY = map.offsetHeight / this.snake.height;
                //小蛇的头的坐标
                var headX = this.snake.body[0].x;
                var headY = this.snake.body[0].y;
                //横坐标
                if (headX < 0 || headX >= maxX) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
                //纵坐标
                if (headY < 0 || headY >= maxY) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
            }.bind(that), 150);
        };

        //添加原型方法---设置用户按键,改变小蛇移动的方向
        Game.prototype.bindKey=function () {

            //获取用户的按键,改变小蛇的方向
            document.addEventListener("keydown",function (e) {
                //这里的this应该是触发keydown的事件的对象---document,
                //所以,这里的this就是document
                //获取按键的值
                switch (e.keyCode){
                    case 37:this.snake.direction="left";break;
                    case 38:this.snake.direction="top";break;
                    case 39:this.snake.direction="right";break;
                    case 40:this.snake.direction="bottom";break;
                }
            }.bind(that),false);
        };

        //把Game暴露给window,外部就可以访问Game对象了
        window.Game = Game;
    }());



    //初始化游戏对象
    var gm = new Game(document.querySelector(".map"));

    //初始化游戏---开始游戏
    gm.init();


    //外部测试代码
    //  var fd = new Food();
    //  fd.init(document.querySelector(".map"));
    //  //创建小蛇
    //  var snake = new Snake();
    //  snake.init(document.querySelector(".map"));//先在地图上看到小蛇
    //
    //
    //
    //  setInterval(function () {
    //    snake.move(fd, document.querySelector(".map"));
    //    snake.init(document.querySelector(".map"));
    //  }, 150);


    //  snake.move(fd, document.querySelector(".map"));//走一步
    //  snake.init(document.querySelector(".map"));//初始化---重新画一条小蛇(先删除之前的小蛇,把现在的小蛇显示出来)

    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));


    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //console.log(fd.x+"====>"+fd.y);

    //console.log(fd.width);



   */

    /*=======================原型以及原型链============================*/
    /*

        //使用对象---》使用对象中的数学和对象中的方法，使用对象就先要有构造函数
    //构造函数
    // function Person(name,age) {
    //     //属性
    //     this.name = name;
    //     this.age = age;
    //     this.sayHi = function () {
    //         console.log("您好，你真帅");
    //     };
    // }
    // //实例化对象，并且初始化
    // for (var  i = 0; i < 100; i++){
    //     var per = new Person("小明",20);
    //     per.sayHi();
    // }

    function Person(name,age) {
        //属性
        this.name = name;
        this.age = age;
        //在构造函数中的方法
        this.eat = function () {
          console.log("吃");
        };
        this.sayHi = function () {
            console.log("您好，你真帅");
        };
    }
    //增加共享的属性和方法
    Person.prototype.sex = "男";
    //增加共享的方法
    Person.prototype.sayHi = function () {
        console.log("您好厊");
    };
    //如果想要使用一些属性和方法，并且熟悉的值在每个对象中都是一样的，方法在每个对象中的操作也都是一样的，那么，为了我共享数据，节省空间，是可以把属性和方法通过原型的方法进行复制
    var per = new Person("小明",20);
    per.sayHi();

    console.dir(per);//实例对象的结构
    console.dir(Person);//构造函数的结构

    //实例对象的原型__proto__和构造函数的原型prototype指向是相同的

    //实例对象中的__proto__原型指向是构造函数中的原型prototype
    console.log(per.__proto__ == Person.prototype);
    //实例对象中__proto__是原型，浏览器中使用的，
    //构造函数中的prototype原型，是程序员用的



     */

    /*=========================原型的指向是否可以改变=====================================*/
    /*

        //构造函数中的this就是实例对象
    //原型对象中方法中的this就是这个实例对象
    // function Person(age) {
    //     this.age = age;
    //     console.log(this);
    // }
    // Person.prototype.eat = function () {
    //     console.log(this);
    //     console.log("您吃饭了么");
    // };
    // var per  = new Person(10);
    // per.eat();
    // console.log(per);


   //  function Student(age) {
   //      this.age = age;
   //      console.log(this);
   //  }
   //  Student.prototype.study = function () {
   //      console.log("学习");
   //  };
   //  Student.prototype = {
   //      eat:function () {
   //          console.log("好吃");
   //      }
   //  };
   // var stu = new Student();
   // stu.eat();


    //这是人的构造函数
    function Person(age) {
        this.age = 10;
        console.log(this);
    }
    //人的饿原型对象方法
    Person.prototype.eat = function () {
        console.log("吃饭🍚");
    };
    //学生的构造函数
    function Student(){
    }
    Student.prototype.sayHi = function(){
      console.log("嗨喽，我很帅的");
    };
    //学生的原型，指向了一个人的实例对象
    Student.prototype = new Person(10);
    var stu = new Student();
    stu.eat();
    //stu.sayHi();

    //原型指向可以改变
    //实例对象的原型__proto__指向是改对象所在的构造函数的原型对象
    //构造函数的原型对象（prrototype）指向如果改变了，实例对象的原型(__proto__)指向也会改变
    //原型的指向是可以改变的
    //实例对象和原型对象之间的关系是通过__proto__原型来联系起来的，这个关系就是原型链

     */

    /*=======================原型最终指向了哪里=======================================================*/
    /*

        function Person() {

    }
    Person.prototype.eat = function () {
        console.log("吃东西");
    };
    var per = new Person();
    console.dir(per);//实例对象
    console.dir(Person);//构造函数

    //实例对象中有__proto__原型
    //构造函数中有prototype原型
    //prototype是对象
    //所有prototype这个对象中也有__proto__原型，指向到哪里？
    //实例对象中的__proto__指向是构造函数的prototype
    //所有prototype这个对象中__proto__指向的应该是某个构造函数的原型prototype

    //Person的prototype
    console.log(Person.prototype.__proto__);

    //实例对象__proto__---》Person.prototype的__proto__---->Object.prototype的__proto__是null

    console.log(per.__proto__ == Person.prototype);
    console.log(per.__proto__.__proto__ == Person.prototype.__proto__);
    console.log(Person.prototype.__proto__ == Object.prototype);
    console.log(Object.prototype.__proto__);
     */

    /*====================原型指向改变如何增加方法和访问=================================================================*/
    /*

         // //人的构造函数
     //  function Person(age) {
     //      this.age = age;
     //  }
     //  //人的原型中添加方法
     //  Person.prototype.eat = function () {
     //      console.log("人吃东西");
     //  };
     //
     //  //学生的构造函数
     //  function Student(sex) {
     //      this.sex = sex;
     //  }
     //  //学生的原型中添加方法---先在原型中添加方法
     //  Student.prototype.sayHi = function () {
     //      console.log("您好啊")
     //  };
     //  //改变原型对象的指向
     //  Student.prototype = new Person(10);
     //
     //  var stu = new Student("男");
     //  stu.sayHi();//不能被访问
     //  stu.eat();







    // //人的构造函数
    // function Person(age) {
    //     this.age = age;
    // }
    //
    // //人的原型中添加方法
    // Person.prototype.eat = function () {
    //     console.log("人吃东西");
    // };
    //
    // //学生的构造函数
    // function Student(sex) {
    //     this.sex = sex;
    // }
    //
    // //改变原型对象的指向
    // Student.prototype = new Person(10);
    // //学生的原型中添加方法---先在原型中添加方法
    // Student.prototype.sayHi = function () {
    //     console.log("您好啊")
    // };
    // var stu = new Student("男");
    // stu.sayHi();//能被访问
    // stu.eat();
    // //一定要在原型对象之前添加方法
    // console.dir(stu);
    // //如果原型指向改变了。那么就应该在原型改变之后增加原型方法





    function Person(age) {
        this.age = age;
    }

    Person.prototype = {
        eat:function () {
            console.log("吃");
        }
    };
     //指向改变了。先添加方法，后改变指向，所有不能访问
     Person.prototype.sayHi = function () {
         console.log("您好");
     };
    var per  = new Person(10);
    per.sayHi();


     */

    /*=====================实例对象的属性和原型对象中的属性重名问题============================================*/
    /*

        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }
        Person.prototype.sex = "女";
        var per = new Person(10,"男");
        console.log(per.sex);
        console.dir(per);
        //以为js是一门动态类型的语言，对象没有什么，只要点了，那么这对象就有了这个东西，没有这个属性，只要对象.属性名字，对象就有这个属性了，但是，改属性没有复制，所以，结果就是：undefined
        console.log(per.nioononnin);


        //实例对象，访问这个属性，先从实例对象中找，找到了就直接用，找不到就去指向的原型对象中找，找到了就使用，找不到，就报错
        //通过实例对象能否改变原型对象中的属性值？不能
        per.sex = "人";
        console.log(per.sex);
        console.dir(per);


        //就是想要改变原型对象中的属性值怎么办？直接通过原型对象.属性 = 值；可以改变，如果找不到，就是undefined
        Person.prototype.sex = "我改变了";
        per.sex = "人";
        console.log(per.sex);
        console.dir(per);

     */

    /*=========================一个很神奇的原型链=================================*/
    /*


    <div id="dv"></div>

    //原型链：实例对象和原型对象之间的关系，通过__proto__来联系的

    var divObj = document.getElementById("dv");
    console.dir(divObj);

    //divObj.__proto__---->HTMLDivElement.prototype的__proto__----->指向的HTMLElement.prototype的__proto__----->指向的是Element.prototype的__proto__---->指向的是Node.prototype的__proto__---->指向是EventTarget.prototype的__proto---->指向Object.prototype没有__proto__没有
    //所以，prototype中的__proto__是null
     */

    /*============================继承========================================*/

    /*
    *
    * 面向对象编程思想:根据需求,分析对象,找到对象有什么特征和行为,通过代码的方式来实现需求,要想实现这个需求,就要创建对象,要想创建对象,就应该显示有构造函数,然后通过构造函数来创建对象.,通过对象调用属性和方法来实现相应的功能及需求,即可
    * 首先JS不是一门面向对象的语言,JS是一门基于对象的语言,那么为什么学习js还要学习面向对象,因为面向对象的思想适合于人的想法,编程起来会更加的方便,及后期的维护....
    * 面向对象的编程语言中有类(class)的概念(也是一种特殊的数据类型),但是JS不是面向对象的语言,所以,JS中没有类(class),但是JS可以模拟面向对象的思想编程,JS中会通过构造函数来模拟类的概念(class)
    *
    *
    *
    *
    * 小明,小红，小丽，小白，小花 都是人
    * 共同的特征和行为
    * 特征--->属性
    * 行为---方法
    *
    * 面向对象的特性:封装,继承,多态
    *
    * 封装:就是包装
    * 一个值存储在一个变量中--封装
    * 一坨重复代码放在一个函数中--封装
    * 一系列的属性放在一个对象中--封装
    * 一些功能类似的函数(方法)放在一个对象中--封装
    * 好多相类似的对象放在一个js文件中---封装
    *
    * 继承: 首先继承是一种关系,类(class)与类之间的关系,JS中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承
    * 继承也是为了数据共享,js中的继承也是为了实现数据共享
    *
    * 原型作用之一:数据共享,节省内存空间
    * 原型作用之二:为了实现继承
    *
    * 继承是一种关系:
    *
    * 父类级别与类级别的关系
    *
    * 例子:
    *
    * 小杨--->人, 姓名, 有钱, 帅, 有功夫--降龙十八掌
    * 小杨子-->人,
    * 继承:
    * 姓氏----继承
    * 外表----继承
    * 财产----继承
    * 功夫---继承
    *
    *
    * 人:  姓名, 性别, 年龄 ,吃饭, 睡觉
    *
    * 学生类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 学习行为
    * 老师类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资,教学行为
    * 程序员: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资, 敲代码
    * 司机类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资 开车
    *
    *
    * 动物类别:  体重， 颜色, 吃
    * 狗类别:   体重,颜色, 吃, 咬人
    * 二哈类别: 体重,颜色, 吃, 咬人 逗主人开心,汪汪,你好帅
    *
    *
    *
    *
    *
    *
    * 多态:一个对象有不同的行为,或者是同一个行为针对不同的对象,产生不同的结果,要想有多态,就要先有继承,js中可以模拟多态,但是不会去使用,也不会模拟,
    *
    *
    *
    *
    *
    * */


    /*
        //例子:
        //人,都有姓名,性别,年龄, 吃饭, 睡觉, 玩
        //学生,都有姓名,性别,年龄, 成绩, 吃饭, 睡觉, 玩 ,学习的行为


        //js中通过原型来实现继承

        function Person(name,age,sex) {
            this.name=name;
            this.sex=sex;
            this.age=age;
        }
        Person.prototype.eat=function () {
            console.log("人可以吃东西");
        };
        Person.prototype.sleep=function () {
            console.log("人在睡觉");
        };
        Person.prototype.play=function () {
            console.log("生活就是不一样的玩法而已");
        };

        function Student(score) {
            this.score=score;
        }
        //改变学生的原型的指向即可==========>学生和人已经发生关系
        Student.prototype=new Person("小明",10,"男");
        Student.prototype.study=function () {
            console.log("学习很累很累的哦.");
        };

        //相同的代码太多,造成了代码的冗余(重复的代码)

        var stu=new Student(100);
        console.log(stu.name);
        console.log(stu.age);
        console.log(stu.sex);
        stu.eat();
        stu.play();
        stu.sleep();
        console.log("下面的是学生对象中自己有的");
        console.log(stu.score);
        stu.study();

     */

    /*================================继承案例=======================================*/
    /*


        //动物有名字,有体重,有吃东西的行为
        //小狗有名字,有体重,有毛色, 有吃东西的行为,还有咬人的行为
        //哈士奇名字,有体重,有毛色,性别, 有吃东西的行为,还有咬人的行为,逗主人开心的行为


        //动物的构造函数
        function Animal(name,weight) {
            this.name=name;
            this.weight=weight;
        }
        //动物的原型的方法
        Animal.prototype.eat=function () {
            console.log("天天吃东西,就是吃");
        };

        //狗的构造函数
        function Dog(color) {
            this.color=color;
        }
        Dog.prototype=new Animal("哮天犬","50kg");
        Dog.prototype.bitePerson=function () {
            console.log("哼~汪汪~咬死你");
        };


        //哈士奇
        function ErHa(sex) {
            this.sex=sex;
        }
        ErHa.prototype=new Dog("黑白色");
        ErHa.prototype.playHost=function () {
            console.log("哈哈~咬坏衣服,咬坏桌子,拆家..嘎嘎...好玩,开心不,惊喜不,意外不");
        };
        var erHa=new ErHa("雄性");
        console.log(erHa.name,erHa.weight,erHa.color);
        erHa.eat();
        erHa.bitePerson();
        erHa.playHost();


     */


    /*=============================原型链==================================================*/



    /*=======================借用构造函数继承==============================*/
    /*    function Person(name,age,sex,weight) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.weight = weight;
        }
        Person.prototype.sayHi = function () {
            console.log("您好");
        };
        function student(score) {
          this.score = score;
        }
        //继承
        stu1dent.prototype = new Person("小明",10,"男","50kg");
        var stu1 = new stu1dent("100");
        console.log(stu1.name,stu1.age,stu1.weight,stu1.sex,stu1.score);
        stu1.sayHi();

        var stu2 = new stu1dent("120");
        stu2.name = "张三";
        stu2.sex = "女";
        stu2.age = "18";
        stu2.weight = "48kg";
        console.log(stu2.name,stu2.age,stu2.weight,stu2.sex,stu2.score);


        var stu3 = new student("130");
        console.log(stu3.name,stu3.age,stu3.weight,stu3.sex,stu3.score);
        stu3.sayHi();

        //为了数据共享，改变原型指向，做到了继承，---通过改变原型指向实现的继承
        //缺陷：因为改变原型指向的同时实现继承，直接初始化了属性，继承过来的属性的值都是一样的了，所有，这就是问题
        //只能重新调用对象.赋值就可以了*/





    /*
    //解决方法：继承的时候，不用改变原型的指向，直接调用父级的构造函数的方式来为属性赋值就可以了，----借用构造函数（把要继承的父级的构造函数拿过来，使用一下，就可以了）

    //借用构造函数：构造函数名字.call(当前对象,属性，属性，属性.... )
    //解决了属性继承，并且值不重复的问题
    //缺陷：父级类别中的方法不能继承

       function Person(name,age,sex,weight) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.weight = weight;
        }
        Person.prototype.sayHi = function () {
            console.log("您好");
        };
        function student(name,age,sex,weight,score) {
            //借用构造函数
            Person.call(this,name,age,sex,weight);
          this.score = score;
        }
        var stu1 = new student("小明",10,"男","10kg","100");
        console.log(stu1.name,stu1.age,stu1.weight,stu1.sex,stu1.score);

        var stu2 = new student("小红",20,"女","20kg","120");
        console.log(stu2.name,stu2.age,stu2.weight,stu2.sex,stu2.score);

        var stu3 = new student("小黄",30,"男","50kg","900");
        console.log(stu3.name,stu3.age,stu3.weight,stu3.sex,stu3.score);


   */

    /*==============================组合继承============================================================*/
    /*
        //原型继承
        //借用构造函数实现基础
        //组合继承：原型继承+借用构造函数基础



        function Person(name,age,sex) {
            this.name=name;
            this.age=age;
            this.sex=sex;
        }
        Person.prototype.sayHi=function () {
            console.log("阿涅哈斯诶呦");
        };
        function Student(name,age,sex,score) {
            //借用构造函数:属性值重复的问题
            Person.call(this,name,age,sex);
            this.score=score;
        }
        //改变了原型指向--可以实现基础
        Student.prototype = new Person();//不传值
        Student.prototype.eat = function () {
            console.log("吃东西");
        };
        var stu = new Student("小呗",20,"男","100分");
        console.log(stu.name,stu.age,stu.sex,stu.score);
        stu.sayHi();
        stu.eat();
        //属性和方法都被继承了
        var stu1 = new Student("小白",220,"男2","1200分");
        console.log(stu1.name,stu1.age,stu1.sex,stu1.score);
        stu1.sayHi();
        stu1.eat();

     */
    /*============================拷贝继承=====================================*/

    /*

        //拷贝继承：吧一个对象中的数学或者方法直接赋值到另外一个对象中
        // var obj1 = {
        //     name:"小糊涂",
        //     age:20,
        //     sleep:function () {
        //         console.log("睡觉");
        //     }
        // };
        //
        // //改变了地址的指向
        // var obj2 = obj1;
        // console.log(obj2.name,obj2.age);
        // obj2.sleep();






        // var obj1 = {
        //     name:"小糊涂",
        //     age:20,
        //     sleep:function () {
        //         console.log("睡觉");
        //     }
        // };
        // //改变了地址的指向
        // var obj2 = {};
        // for (var key in obj1){
        //     // obj2.name = obj1.name;
        //     // obj2.age = obj1.age;
        //     obj2[key] = obj1[key];
        // }
        // console.log(obj2.name,obj2.age);
        // obj2.sleep();


     */

    /*
    function Person() {

    }

    Person.prototype.age = 10;
    Person.prototype.sex = "男";
    Person.prototype.height = 100;
    Person.prototype.play = function () {
        console.log("好开心");
    };
    var obj2 = {};


    //Person的构造中有原型prototype，prototype就是一个对象，那么里面，age,sex,height,play都是该对象中的属性或者是方法

        for (var key in Person.prototype){
            obj2[key] = Person.prototype[key];
        }
        console.dir(obj2);
        obj2.play();
     */
    /*==========================继承=========================================*/


    //面向对象特征：封装，继承，多态
    //继承：类与类之间的关系，面向对象的语言继承，是为了多态服务的
    //js不是面向对象的语言，但是可以模拟面向对象，模拟继承，为了节省内存空间


    //继承：
    /**
     * 原型作用：数据共享，原型目的：为了节省内存空间
     * 原型作用：继承，节省内存空间
     *
     * 原型继承：改变原型指向
     * 借用构造函数继承：主要解决属性的问题
     * 组合继承：原型继承+借用构造函数继承
     * 组合继承既能解决属性问题，又可以解决方法问题
     * 拷贝继承：吧对象需要共享的属性和方法，直接遍历的方式复制到另一个对象中
     *
     */

    /*==============================逆推继承看原型=================================*/
    /*    function F1(age) {
            this.age = age;
        }
        function F2(age) {
            this.age = age;
        }
        F2.prototype = new F1(10);
        function F3(age) {
            this.age = age;
        }
        F3.prototype = new F2(20);

        var f3 = new F3(30);
        console.log(f3.age);*/


    /*=============================函数的角色及函数声明和函数表达式的区别============================================*/
    /*


    //函数的角色:
    //函数声明
    function f1() {
        console.log("我是函数");
    }
    f1();
    //函数表达式
    var ff = function () {
        console.log("我也是一个函数");
    };
    ff();

    */

/*

    //函数声明
    // if (true){
    //     function f1() {
    //         console.log("哈哈，我很帅");
    //     }
    // } else {
    //     function f1() {
    //         console.log("嘻嘻，我很帅");
    //     }
    // }
    // f1();

    //函数表达式
    var ff;
    if(true) {
        ff = function () {
            console.log("哈哈，我很帅");
        }
    } else {
        ff = function () {
            console.log("嘻嘻，我很帅");
        }
    }
    ff();

    //函数声明如果放在if-else语句找你哥，在IE8的浏览器中会出现问题
    //以后宁愿用函数表达式，都不用函数声明
 */

/*=================函数中的this和严格模式============================*/
    //函数中的this的指向
    //普通函数中this是谁？----------window
    //对象.方法中this是谁？----------当前的实例对象
    //定时器方法中的this是谁-----------window
    //构造函数的this-----------------实例对象
    //原型对象this-------------------实例对象

   /*
    //函数中的this的指向
    function f1() {
        console.log(this);
    }
    f1();
    //BOM：中顶级对象是window；浏览器所有的东西都是window
    //this是window
    */

    /*
    //定时器方法中的this是谁
    setInterval(function () {
        console.log(this);
    },1000)
    //this是window
     */

    /*

    //构造函数的this
     function Person() {
        console.log(this);
        this.sayHi = function () {
            console.log(this);
        };
    }
    Person.prototype.eat = function () {
          console.log(this);
    };
    var per = new Person();
    console.log(per);
    per.sayHi();
    per.eat();
    //this是实例对象
    //this是实例对象

     */


    /*

     //严格模式:
    "use strict";//严格模式
    function f1() {
        console.log(this);
    }
    window.f1();

     */

/*========================函数的不同的调用方式==========================================*/
/*
    //普通函数
    function f1() {
        console.log("文能提笔控萝莉")
    }
    f1();

    //构造函数---通过new 来调用，目的用来创建对象
    function F1() {
        console.log("我是构造函数");
    }
    var f = new F1();


    //对象的方法--对象.方法来调用的
    function Person() {
        this.play = function () {
            console.log("完");
        };
    }
    var per = new Person();
    per.play();

 */

/*===================函数也是对象========================================*/
/*

  //函数是对象，对象不一定是函数
    //对象中__proto__原型，是对象
    //构造函数有prototype原型，是对象
    // function F1() {
    // }
    // console.dir(F1);
    //
    //
    // console.dir(Math);//中有__proto__，但是没有prototype

    //对象中有__proto__,函数中应该有prototype

    //如果一个东西里面有prototype,又有__proto__，说明是函数，也是对象





    // function F2(name) {
    //     this.name = name;
    // }
    // console.dir(F2);
    //所有的函数实际上都是Function的构造函数创建出来的实例对象

    var f2 = new Function("num1","num2","return num1+num2");
    console.log(f2(10,20));

    //所有，函数实际也是对象
    console.dir(f2);

 */


/*=======================数组中函数的调用==============================================================*/
/*

    //数组中可以存储任何类型的数据
    var arr = [
        function () {
            console.log("放假了1");
        },
        function () {
            console.log("放假了2");

        },
        function () {
            console.log("放假了3");

        },
        function () {
            console.log("放假了4");

        },
    ];
    arr.forEach(function (ele) {
        ele();
    })

 */

/*============================apply和call的方法======================================*/
    /*

        // apply和call的使用
    //作用：可以改变this的指向

    function f1(x,y) {
        console.log("结果是："+(x+y)+this);
        return "1000000";
    }
    f1(10,20);//函数的调用

    console.log("===========");
    //此时的f1实际上市当成对象来使用的，对象可以调用方法的
    //apply和call方法也是函数的调用的方式
    // f1.apply();
    // f1.call();
    console.log("===============");
    // f1.apply(null);
    // f1.call(null);

    //apply 和 call方法中如果没有传入参数，或者是传入的是Null,那么调用改方法的函数对象中的this就是默认的window

    f1.apply(null,[100,200]);
    f1.call(null,100,200);

    //apply 和call都可以让函数或者方法来调用，传入参数和函数自己调用的写法不一样，但是效果是一样的
    var result1 =  f1.apply(null,[1200,200]);
    var result2 = f1.call(null,1200,200);
    console.log(result1);
    console.log(result2);

    function f2(x,y) {
        console.log("这个函数window对象的一个方法"+(x+y)+this);//40[object Window]
    }
    window.f2(10,30);

    //obj是一个对象
    var obj = {
        age:10,
        sex:"男",
    };
    window.f2.apply(obj,[10,20]);//30[object Object]
    window.f1.call(obj,10,20);
    console.dir(obj);

    //apply和call可以改变this的指向

    function Person(age,sex) {
        this.age = age;
        this.sex = sex;
    }
    //通过原型添加方法
    Person.prototype.sayHi = function () {
        console.log("你好啊"+this.sex);
        return 1000;
    };
    var per = new Person(10,"男");
    per.sayHi();

    console.log("=======================");
    function Student(name,sex) {
        this.name = name;
        this.sex = sex;
    }
    var stu = new Student("小明","人妖");
    var r1 = per.sayHi.apply(stu,[10,20]);
    var r2 = per.sayHi.call(stu,10,20);
    console.log(r1);
    console.log(r2);

     */



    /*

        //apply和call都可以改变this的指向
    //函数的调用，改变this的指向
    function f1(x, y) {
        console.log((x + y) + ":===》" + this);
        return "这是函数的返回值";
    }

    //apply和call调用
    var r1 = f1.apply(null, [1, 2]);//此时f1中的this是window
    console.log(r1);

    //call调用
    var r2 = f1.call(null, 1, 2);//此时f1中的this是window
    console.log(r2);

    console.log("===============");
    //改变this的指向
    var obj = {
        sex : "男"
    };
    //本来f1函数是window的，但是传入obj，this就是object的了
    //apply调用
    var r1 = f1.apply(obj, [1, 2]);//此时f1中的this是object
    console.log(r1);

    //call调用
    var r2 = f1.call(obj, 1, 2);//此时f1中的this是object
    console.log(r2);

     */


    /*

    //    方法改变this的指向
    function Person(age) {
        this.age = age;
    }
    Person.prototype.sayHi = function (x,y) {
        console.log((x+y)+":====>"+this.age);//是实例对象
    };

    function Student() {

    }
    var per = new Person(10);//实例对象
    var stu = new Student();//实例对象
    //sayHi 方法是per实例对象的方法
    per.sayHi.apply(stu,[10,20]);
    per.sayHi.call(stu,10,20);


    //apply 和call的使用方法
    // apply的使用语法：
    // 函数名字.apply(对象,[参数1,参数2,....]);
    // 方法名字.apply(对象,[参数1,参数2,....]);
    //
    //call的使用语法：
    //函数名字.call(对象,参数1,参数2);
    //方法名字.call(对象,参数1,参数2);
    //
    //作用：改变this的指向
    //不用的地方：参数传递的方式是不一样的
    //只要是想使用别的对象的方法，并且希望这个方法是当前对象的，那么就可以使用apply或者是call的方法改变this的指向




     */


/*=========================apply和call方法到底是谁的=========================================*/


    /*=============================bind的方法================================*/


    /*

        // function f1(x,y) {
    //     console.log((x+y)+":====>"+this);//30:====>[object Window]
    // }
    // f1(10,20);

    function f1(x,y) {
        console.log((x+y)+":====>"+this);//30:====>[object Window]
    }
    //复制了一份的时候，把一个参数传入到了f1函数中，x==>10,y===>20，null就是this,默认就是window
    // var ff = f1.bind(null,10,20);
    // ff();

    //bind方法是复制的意思，参数可以在复制的时候传进去，也可以在复制之后调用的时候传入
    var ff = f1.bind(null);
    ff(10,20);

     */


    /*

     //apply和call是调用的时候改变this的指向
        //bind方法，是复制一份的时候，改变this的指向

    function Person() {
        this.age = 1000;
    }

    Person.prototype.sayHi = function () {
        console.log("hey");
    };

    var per = new Person();

    var ff = f1.bind(per,10,20);
    ff();//30:====>[object Object]

     */


    /*

       function Person(age) {
       this.age = age;
   }
   Person.prototype.play = function () {
       console.log(this+":===>"+this.age);
   };

   function Student(age) {
       this.age = age;
   }
   var per = new Person(18);
    var stu = new Student(20);
    //复制了一份
    var ff =per.play.bind(stu);
    ff();


     */
    //bind是复制了一份
    //使用方法
    /*

        函数名字.bind(对象，参数1，参数2。。。。);---》返回值是复制之后的这个函数
        方法名字.bind(对象，参数1，参数2。。。。);----》返回值是复制之后的这个方法

     */

    /////////////////////////////////////////bind的使用
/*    //通过对象，调用方法，产生随机数
    function ShowRandom() {
        this.number = parseInt(Math.random()*10+1);//1-10的随机数

    }
    //增加原型方法
    ShowRandom.prototype.show1  = function () {
        //改变了定时器中的this的指向了，本来应该是window,显示是实例对象了
        window.setInterval(this.show2.bind(this),1000);
    };
    ShowRandom.prototype.show2 = function () {
        //显示随机数
        console.log(this.number);
    };
    //实例对象
    var sr = new ShowRandom();
    //调用方法，输出随机数字
    //调用这个方法一次，不停产生随机数
    sr.show1();*/


/*==========================函数中的几个成员==================================*/
/*
    //函数中有一个name的属性---》函数的名字,name属性只读，不能改变函数的名字
    //函数中有一个arguments属性，---》实参的个数
    //函数中有一个length的属性----》函数定义的时候形参的个数
    //函数中有一个caller属性---》调用f1函数子在f2函数中调用，所有，此时调用者就是f2
    function f1(x,y) {
        console.log(f1.name);
        console.log(f1.arguments.length);//实参的个数
        console.log(f1.length);
        console.log(f1.caller);//调用者
    }
    f1.naem = "f5";
    f1(10,20);
    console.dir(f1);

    function f2() {
        console.log("f2代码");
        f1(1,2)
    }
    f2();

 */

/*=============================函数作为参数使用=====================================*/
    /*

        function f1(fn) {
        console.log("f1的函数");
        fn();//此时fn当做是一个函数来使用
    }
    //fn是参数，最后作为函数使用了，函数是可以作为参数使用
    f1(function () {
        console.log("我是匿名函数");
    });
    //命名函数
    function f2() {
        console.log("f2的函数");
    }
    f1(f2);

    //函数作为参数的时候，如果是命名函数，那么只传入命名函数的名字，没有括号

     */


</script>
</html>