<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <link rel="stylesheet" href="">
</head>
<body>

</body>
<script type="text/javascript">
    /*==================================创建对象的三种方式===================================*/
    /*

       //对象：特值的某个事物，具有属性和方法（一组无序的属性的集合）
        //特征---》属性
        //行为---》方法
        //小汪--》姓名,性别，年龄，吃，睡觉，玩

        //创建对象三种方式：
    //    1.字面量的
    //    2.调用系统的构造函数
    //    3.自定义构造函数方式


        //字面量
        var per1 = {
           name:"xixi",
           age:20,
            sex:"男",
             eat:function () {
                 console.log("吃饭");
             },
            readBook:function () {
                console.log("散文诗歌");
            }
        };

        //调用系统函数的构造函数
        var per2 = new Object();
        per2.name = "haha";
        per2.age = 18;
        per2.sex = function () {
            console.log("吃榴莲")
        };
        per2.play = function () {
            console.log("真好玩")
        };
        function Person(){

        }
        //console.log(per2 instanceof Person)
        console.log(per2 instanceof Object);


    //自定义构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;

            this.play = function () {
                console.log("好玩");
            };
        }
        var per =  new Person("汪程序员",19,"女");
        console.log(per instanceof Person);
        console.log(per);
     */

    /*==================================自定义构造函数创建对象做的事情================================================*/
    /*


        function Person(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.play = function () {
            console.log("跑步");
        };
    }
    //创建对象---》实例化一个对象的同时对属性进行初始化
    var per = new Person("小汪",18,"男");
    console.log(per);

*/
    /*
    * 1.开辟空间存储对象
    * 2.把this设置当前的对象
    * 3.设置属性和方法的值
    * 4.把this对象返回
    * */
    /*============================工厂模式=====================================*/
    /*

        // 工厂模式创建对象
    function createObject(name,age) {
        var  obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.sayHi = function () {
            console.log("你好");
        };
        return obj;
    }

    var per = createObject("小汪",19);
    console.log(per);
     */


    /*
    *  自定义构造函数与工厂模式
    *  共同点：都是函数，都可以创建对象，都可以传入参数
    *
    *  工厂模式：函数名是小写,
    *           有new，有返回值
    *           new之后对象是当前的对象
    *           直接调用函数就可以创建对象
    *
    *
    *  自定义构造函数：函数名首字母是大写的，
    *               没有new，没有返回值
    *               this是当前的对象
    *               通过new的方式创建对象的
    *
    *
    * */


    /*=======================构造函数和实例对象之间的关系=======================================*/
    /*

       //面向对象的思想是------抽象的过程----实例化的过程
        //我这个人：姓名，年龄，性别，吃饭，打招呼，睡觉。。。
        //自定义构造函数---实例化对象
        //这是构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.sayHi = function () {
                console.log("hello");
            };
            this.sleep = function () {
                console.log("sleep")
            };
            this.eat = function () {
                console.log("吃");
            }
        }//构造函数end


        //构造函数---》创建对象
        var per = new Person("汪洋",28,"男");
        per.eat();
        //实例对象是通过构造函数来创建
        //实例对象会指向自己的构造函数（暂时理解，是错误的）


        console.dir(per);//把这个对象的结构显示出来
        console.dir(Person);
        //实例对象的构造器是指向Person的，结构是true，所以，这个实例对象per就是通过Person来创建的
        console.log(per.constructor==Person);//true   //实例对象的构造器（构造函数）
        console.log(per.__proto__.constructor==Person);//true
        console.log(per.__proto__.constructor == Person.prototype.constructor);//true

        //构造函数
        function Animal(name) {
            this.name = name;
        }
        //实例对象
        var dog = new Animal("大黄");
        console.dir(dog);//实例对象
        console.dir(Animal);//构造函数的名字

        console.log(dog.__proto__.constructor == Person);//false
        console.log(dog.__proto__.constructor == Animal);//true

        //判断这个是不是这种数据类型
        console.log(dog.constructor==Animal);
        console.log(dog instanceof Person);
     */

    //总结：
    /**
     * 实例对象和构造函数之间的关系
     * 1.实例对象是通过 构造函数来创建的----创建的构成叫实例化
     * 2.如何判断对象是不是这个数据类型
     *   1）通过构造器的方式实例对象，构造器==构造函数名字
     *   2）对象instanceof构造函数名字
     *   尽可能使用 第二种方式来识别，为什么？原型讲完就明白了
     *
     *
     */
    /*=============================原型引入==================================*/
    //数据共享，节省内存空间，作用之一
    /*
    function Person(name,age) {
        this.name = name;
        this.age = age;
        this.eat = function () {
            console.log("吃肉");
        }
    }
    var per1 = new Person("小白",20);
    var per2 = new Person("小黑",22);
    per1.eat();
    per2.eat();
    //不是同一个方法
    console.log(per1.eat == per2.eat);//false,这两个不是同一个对象，也不是调用同一个方法

    console.dir(per1);
    console.log(per2);
*/

    /*
    function myEat() {
        console.log("吃肉");
    }

    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.eat = myEat;
    }

    var per1 = new Person("小白", 20);
    var per2 = new Person("小黑", 22);
    per1.eat();
    per2.eat();

    console.log(per1.eat == per2.eat);//true

      //实例对象中根本没有eat方法，但是能够使用，这是为什么呢？
    //window是对象
    //document是属性，document也是一个对象
    //write()是方法
    //window.document.write("哈哈");
    //对象.style.color=值;

    */

    /**
     *  原型？
     *  实例对象中有__proto__这个属性，叫原型，也是一个对象，这个属性是给浏览器使用的，不是标准属性
     *  构造函数中有prototype这个属性，叫做原型，也是一个对象,这个属性，是给程序员用的，是标准的属性----》prototype---》可以叫做原型对象
     *  实例对象的__proto__和构造函数中的prototype相等 ---》true
     *  有因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype
     *  实例对象的__proto__指向了构造函数的原型对象prototype
     *
     *
     */

    /*=======================================体会面向过程和面向对象思想编程============================================*/
    /*

        <style>
        #dv {
            width: 200px;
            height: 300px;
            background-color: red;
        }
    </style>

</head>
<body>
<input type="button" value="显示效果" id="btn">
<div id="dv"></div>

    //点击按钮，改变div的背景颜色

    //面向过程
    // my$("btn").onclick = function () {
    //     my$("dv").style.backgroundColor = "yellow";
    // };

       // function Person() {
    //     this.sayHi = function () {
    //         console.log(this);
    //     };
    // }
    // var per  = new Person();
    // per.sayHi();


     */

    /*    //面向对象写法：---初级
    //按钮是一个对象，div是一个对象，颜色是一个属性
    function ChangeStyle(btnId, dvId, color) {
        this.btnObj = my$(btnId);//按钮对象
        this.dvObj = my$(dvId);//div的对象
        this.color = color;//颜色
    }

    //数据共享来改变背景颜色
    ChangeStyle.prototype.init = function () {
        //console.log(this);//就是实例对象--当前对象
        var that = this;
        this.btnObj.onclick = function () {
            that.dvObj.style.backgroundColor = that.color;
        }
    };

    //实例化对象
    var cs = new ChangeStyle("btn", "dv", "yellow");
    cs.init();


    //❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️
      //面向对象写法：---高级
    function ChangeStyle(btnObj, dvObj, json) {
        this.btnObj = btnObj;
        this.dvObj = dvObj;
        this.json = json;
    }
    ChangeStyle.prototype.init = function () {
        //点击按钮，改变div对个样式属性
        var that = this;
        this.btnObj.onclick = function () {//按钮
            for (var key in that.json){
                that.dvObj.style[key] = that.json[key];
            }
        }
    };
    //实例化对象
    var json = {"width":"500px","height":"800px","backgroundColor":"yellow"};
    var cs = new ChangeStyle(my$("btn"),my$("dv"),json);
    cs.init();//调用方法

*/

    /*============================复习原型==============================*/
    /*
       //构造函数
       function Person(name,age) {
           this.name = name;
           this.age = age;
       }
       //通过原型增加方法
        Person.prototype.sayHi = function () {
            console.log("hey");
        };
        var per = new Person("小明",20);
        console.dir(per);
        console.dir(Person);

        var per2 = new Person("女",20);
        console.log(per.sayHi == per2.sayHi);//true

        //实例对象中，有两个属性（这两个属性是通过构造函数来获取的），__proto__这个属性
        //构造函数中并没有sex和age的两个属性
     */

    /**
     * 实例对象中有个属性__proto__，也是对象，叫原型，不是标准的属性，浏览器使用的
     * 构造函数中有一个属性，prototype,也是对象，叫原型，程序员用的
     * 原型----》__proto__或者是prototype，都是原型对象
     * 原型的作用：共享数据，节省内存空间
     *
     */

    /*============================构造函数和实例对象和原型对象的关系================================*/

    /*


        //荣光构造函数实例对象，并且初始化
        var arr = new Array(10,20,30,40);
        //var per = new Person("小明",20,"男");
        //join是方法，实例对象调用的方法
        arr.join("|");
        console.log(arr);
        //join方法在实例对象__proto__原型中
         console.log(arr.__proto__ == Array.prototype);//true

        //构造函数
        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }

        //通过构造函数的原型增加一个方法
        Person.prototype.eat = function () {
            console.log("吃饭");
        };
        var per = new Person(20,"男");
        per.eat();

        //构造函数和原型对象和实例对象的关系
        console.dir(Person);
        console.dir(per);
     */
    /**
     * 1.通过构造函数创建实例对象
     * 2.原型在构造函数里面
     * 3.实例对象可以调用方法
     */


    /*======================总结三者之间的关系=============================*/

    //总结三种的关系

    /**
     * 构造函数可以实例化对象
     * 构造函数中有一个函数叫prototype，是构造函数的原型对象、
     * 构造函数的原型对象（prototype）中有一个constructor构造器，这个构造器指向的就是自己所在的原型对象所在的构造函数
     * 实例对象的原型对象（__proto__）指向的是该构造的原型对象
     * 构造函数的原型对象（prototype）中的方法是可以被实例对象直接访问
     *
     *
     */
    /*===========================利用原型共享数据======================================*/
    /*

        //什么样的额数据是需要写在原型中？
    //需要共享的数据就可以写在原型中
    //原型的作用之一：数据共享

    //属性需要共享，方法也需要共享，写在原型中
    //不需要共享的带哦你关系，写在构造函数中

    //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //所有学生的身高188，所有的体重都是55
    //所有的学生每天都要写500行代码
    //所有的学生每天都要吃10斤西瓜
    //原型对象
    Student.prototype.height = "188cm";
    Student.prototype.weight = "55kg";
    Student.prototype.coding = function () {
        console.log("敲代码。500行");
    };
    Student.prototype.eat = function () {
        console.log("吃10斤西瓜");
    };

    //实例化对象，并且初始化
    var stu = new Student("小明",20,"男");
    console.dir(Student);
    console.dir(stu);//方法在__proto__中
    stu.coding();
    stu.eat();


     */

    /*===========================原型的简单语法===================================*/
    /*

        //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //简单的原型写法
    Student.prototype = {
        //手动修改构造器的指向
        constructor:Student,
        height:"188cm",
        weight :"55kg",
        study : function () {
            console.log("学习好开心呀");
        },
        eat : function () {
            console.log("吃饭啦");
        }
    };

    var stu  = new Student("小明",20,"男");
    console.dir(Student);//原型对象
    console.dir(stu);//实例对象
    stu.study();
    stu.eat();




     */

    /*==========================原型中的方法是可以相互访问的==============================*/

    /*    function Person(age) {
            this.age = age;
            this.sayHi = function () {
                console.log("hey");
                //打招呼的同时，直接调用吃的方法
                // this.eat();
            };
            this.eat = function () {
                console.log("吃饭");
                this.sayHi();
            };
        }
        //实例化对象。并且初始化
        var per = new Person(20);
        //调用方法

        //per.sayHi();
        per.eat();

        //实例对象的方法是可以相互调用的*/

    /*
        //原型中的方法是可以相互访问的
        function Animal(name,age) {
            this.name = name;
            this.age = age;
        }
        //原型中添加方法
        Animal.prototype.eat = function () {
            console.log("动物吃东西");
            this.play();
        };
        Animal.prototype.play = function () {
            console.log("玩球");
            this.sleep();
        };
        Animal.prototype.sleep = function () {
            console.log("睡觉");
        };

        var dog = new Animal("小汪",20,"男");
        dog.eat();
        //原型对象中的方法，是可以相互调用的
    */

    /*=======================实例对象使用的属性和方法层层的搜索========================================*/
    /*


        function Person(age,sex) {
        this.age = age;//年龄
        this.sex = sex;//性别
        this.eat = function () {
            console.log("构造函数中的吃");
        };
    }
    Person.prototype.sex = "女";
    Person.prototype.eat = function () {
      console.log("原型对象吃大餐");
    };
    var per  = new Person(20,"男");
    console.log(per.sex);
    per.eat();
    console.dir(Person);
    console.log(per);
    //先从实例化对象中去找，如果实例对象中部存在，就会在原型中去找


     */

    /*

        实例对象使用的属性或者方法，现在实例中查找，找到了则直接使用，找不到则去实例对象的__proto__指向的原型对象prototype中找，找到了则使用，找不到就会报错

     */


    /*=========================为内置对象的原型对象中添加方法======================================*/
    /*

        //为内置对象增加原型对象方法
    var arr = new Array(10,20,30,40);
    arr.join("|");
    console.log(arr);
    console.dir(arr);

    var str = new String("哦，哈哈");
    str.indexOf("哦");
    console.dir(str);
    //实例中的方法如果没有，去创建改实例对象的构造函数的原型对象中找


    //我们能否为系统的对象的原型中增加方法，相当于改变源码
    //我希望字符串中有一个倒序的这个方法
    String.prototype.myReverse = function () {
        for (var i = this.length-1; i >= 0; i--){
            console.log(this[i])
        }
    };
    var str = "abcdefg";
    str.myReverse();


    //为Array内置对象的原型对象中增加方法
    Array.prototype.mySort = function () {
        for (var i = 0; i <this.length- 1; i++){
            for(var j = 0; j < this.length - 1; j++){
                if (this[j] < this[j+1]){
                    var temp = this[j];
                    this[j] = this [j +1];
                    this[j+1]=temp;
                }
            }
        }
    };
    var arr = [100,20,30,4056,30,20];
    arr.mySort();
    console.log(arr);


    String.prototype.sayHi = function () {
        console.log(this+"哈哈，我又变帅了");
    };
    //字符串就有了打招呼的方法了
    var str2 = "小样";
    str2.sayHi();


     */

    /*========================局部变量变成全局变量==================================*/

    /*

        //该函数的自调用
    //一次性的函数，声明的同时，直接调用了
    //页面加载后，这个自调用函数代码，就执行完了
    // (function (形参) {
    //     var num = 10;
    //     console.log(num);
    // })(实参);
    // console.log(num);//报错


    (function (win) {
        var num = 10;
        //js是一门动态类型的语言，对象没有属性，点了就有了
        win.number = num;
    })(window);

    console.log(number);//10


    //如何把局部变量编程全局
    //把局部变量给window就可以了

     */


    /*=====================产生随机数对象==============================================*/

    /*
   //通过自调用函数产生一个随机数对象，在自调用函数外面，调用改随机数对象方法产生随机数

    (function (window) {
        //产生随机数的构造函数
        function Random() {

        }
        //在原型对象中添加方法
        Random.prototype.getRandom = function (min,max) {
            return Math.floor(Math.random()*(max-min)+min);//0-4
        };

        // var rm = new Random();
        // var num = rm.getRandom();
        // console.log(num);

        window.Random = Random;

    })(window);

    console.log(window.Random);
    var rm =new Random();
    console.log(rm.getRandom(10,50));

     */

    /*======================随机小方块=======================================*/
    /*

            .map {
                width: 800px;
                height: 600px;
                background-color: #d3d3d3;
                position: relative;
            }

        </style>
    </head>
    <body>

    <div class="map">
        <div class="minBox"></div>
    </div>


        //自调用构造函数的方式，分号一定要加上

        //产生随机数的对象
        (function (window) {
            function Random() {

            }

            //在原型对象中增加方法
            Random.prototype.gegRandom = function (min, max) {
                return Math.floor(Math.random() * (max - min) + min);
            };
            //吧局部对象暴露给window顶级对象，就成了全局变量对象
            window.Random =new Random;
        })(window);

        console.log(Random.gegRandom(0,5));
        //产生小方块对象
        (function (window) {
            //选择器的方式来获取元素对象
            var map = document.querySelector(".map");
            //食物的构造函数对象
            function Food(width,height,color) {
                this.width = width || 20;//默认小方块的宽
                this.height = height || 20;
                this.color = color;
                this.x = 0;
                this.y = 0;
                this.element = document.createElement("div");//小方块元素
            }
            //初始化小方块的显示效果及位置---显示地图上面
            Food.prototype.init = function (map) {
                //设置小方块的样式
                var div = this.element;
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height =this.height + "px";
                div.style.backgroundColor = this.color;
                map.appendChild(div);//吧小方块加到map中
                this.render(map);
            };
            //产生随机位置
            Food.prototype.render = function (map) {
                //随机产生横纵坐标
                var x = Random.gegRandom(0,map.offsetWidth/this.width)*this.width;
                var y = Random.gegRandom(0,map.offsetHeight/this.height)*this.height;
                this.x = x;
                this.y = y;
                var div = this.element;
                div.style.left = this.x + "px";
                div.style.top = this.y + "px";

            };

            var fd = new Food(20,20,"green");
            fd.init(map);
        })(window);

     */

    /*============================贪吃蛇=====================================*/
    /*

     <style>
        .map {
            width: 800px;
            height: 600px;
            background-color: #CCC;
            position: relative;
        }
    </style>
</head>
<body>
<!--画出地图,设置样式-->
<div class="map"></div>
<script>


    //自调用函数----食物的
    (function () {
        var elements = [];//用来保存每个小方块食物的
        //食物就是一个对象,有宽,有高,有颜色,有横纵坐标,先定义构造函数,然后创建对象
        function Food(x, y, width, height, color) {
            //横纵坐标
            this.x = x || 0;
            this.y = y || 0;
            //宽和高
            this.width = width || 20;
            this.height = height || 20;
            //背景颜色
            this.color = color || "green";
        }

        //为原型添加初始化的方法(作用：在页面上显示这个食物)
        //因为食物要在地图上显示,所以,需要地图的这个参数(map---就是页面上的.class=map的这个div)
        Food.prototype.init = function (map) {
            //先删除这个小食物
            //外部无法访问的函数
            remove();

            //创建div
            var div = document.createElement("div");
            //把div加到map中
            map.appendChild(div);
            //设置div的样式
            div.style.width = this.width + "px";
            div.style.height = this.height + "px";
            div.style.backgroundColor = this.color;
            //先脱离文档流
            div.style.position = "absolute";
            //随机横纵坐标
            this.x = parseInt(Math.random() * (map.offsetWidth / this.width)) * this.width;
            this.y = parseInt(Math.random() * (map.offsetHeight / this.height)) * this.height;
            div.style.left = this.x + "px";
            div.style.top = this.y + "px";

            //把div加入到数组elements中
            elements.push(div);
        };

        //私有的函数---删除食物的
        function remove() {
            //elements数组中有这个食物
            for (var i = 0; i < elements.length; i++) {
                var ele = elements[i];
                //找到这个子元素的父级元素,然后删除这个子元素
                ele.parentNode.removeChild(ele);
                //再次把elements中的这个子元素也要删除
                elements.splice(i, 1);
            }
        }

        //把Food暴露给Window,外部可以使用
        window.Food = Food;
    }());

    //自调用函数---小蛇
    (function () {
        var elements = [];//存放小蛇的每个身体部分
        //小蛇的构造函数
        function Snake(width, height, direction) {
            //小蛇的每个部分的宽
            this.width = width || 20;
            this.height = height || 20;
            //小蛇的身体
            this.body = [
                {x: 3, y: 2, color: "red"},//头
                {x: 2, y: 2, color: "orange"},//身体
                {x: 1, y: 2, color: "orange"}//身体
            ];
            //方向
            this.direction = direction || "right";
        }

        //为原型添加方法--小蛇初始化的方法
        Snake.prototype.init = function (map) {
            //先删除之前的小蛇
            remove();//===========================================

            //循环遍历创建div
            for (var i = 0; i < this.body.length; i++) {
                //数组中的每个数组元素都是一个对象
                var obj = this.body[i];
                //创建div
                var div = document.createElement("div");
                //把div加入到map地图中
                map.appendChild(div);
                //设置div的样式
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height = this.height + "px";
                //横纵坐标
                div.style.left = obj.x * this.width + "px";
                div.style.top = obj.y * this.height + "px";
                //背景颜色
                div.style.backgroundColor = obj.color;
                //方向暂时不定
                //把div加入到elements数组中----目的是为了删除
                elements.push(div);
            }
        };

        //为原型添加方法---小蛇动起来
        Snake.prototype.move = function (food, map) {
            //改变小蛇的身体的坐标位置
            var i = this.body.length - 1;//2
            for (; i > 0; i--) {
                this.body[i].x = this.body[i - 1].x;
                this.body[i].y = this.body[i - 1].y;
            }
            //判断方向---改变小蛇的头的坐标位置
            switch (this.direction) {
                case "right":
                    this.body[0].x += 1;
                    break;
                case "left":
                    this.body[0].x -= 1;
                    break;
                case "top":
                    this.body[0].y -= 1;
                    break;
                case "bottom":
                    this.body[0].y += 1;
                    break;
            }

            //判断有没有吃到食物
            //小蛇的头的坐标和食物的坐标一致
            var headX=this.body[0].x*this.width;
            var headY=this.body[0].y*this.height;
            //判断小蛇的头的坐标和食物的坐标是否相同
            if(headX==food.x&&headY==food.y){
                //获取小蛇的最后的尾巴
                var last=this.body[this.body.length-1];
                //把最后的蛇尾复制一个,重新的加入到小蛇的body中
                this.body.push({
                    x:last.x,
                    y:last.y,
                    color:last.color
                });
                //把食物删除,重新初始化食物
                food.init(map);
            }
        }
        ;//删除小蛇的私有的函数=============================================================================
        function remove() {
            //删除map中的小蛇的每个div,同时删除elements数组中的每个元素,从蛇尾向蛇头方向删除div
            var i = elements.length - 1;
            for (; i >= 0; i--) {
                //先从当前的子元素中找到该子元素的父级元素,然后再弄死这个子元素
                var ele = elements[i];
                //从map地图上删除这个子元素div
                ele.parentNode.removeChild(ele);
                elements.splice(i, 1);
            }
        }

        //把Snake暴露给window,外部可以访问
        window.Snake = Snake;
    }());

    //自调用函数---游戏对象================================================
    (function () {

        var that = null;//该变量的目的就是为了保存游戏Game的实例对象-------

        //游戏的构造函数
        function Game(map) {
            this.food = new Food();//食物对象
            this.snake = new Snake();//小蛇对象
            this.map = map;//地图
            that = this;//保存当前的实例对象到that变量中-----------------此时that就是this
        }

        //初始化游戏-----可以设置小蛇和食物显示出来
        Game.prototype.init = function () {
            //初始化游戏
            //食物初始化
            this.food.init(this.map);
            //小蛇初始化
            this.snake.init(this.map);
            //调用自动移动小蛇的方法========================||调用了小蛇自动移动的方法
            this.runSnake(this.food, this.map);
            //调用按键的方法
            this.bindKey();//========================================
        };

        //添加原型方法---设置小蛇可以自动的跑起来
        Game.prototype.runSnake = function (food, map) {

            //自动的去移动
            var timeId = setInterval(function () {
                //此时的this是window
                //移动小蛇
                this.snake.move(food, map);
                //初始化小蛇
                this.snake.init(map);
                //横坐标的最大值
                var maxX = map.offsetWidth / this.snake.width;
                //纵坐标的最大值
                var maxY = map.offsetHeight / this.snake.height;
                //小蛇的头的坐标
                var headX = this.snake.body[0].x;
                var headY = this.snake.body[0].y;
                //横坐标
                if (headX < 0 || headX >= maxX) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
                //纵坐标
                if (headY < 0 || headY >= maxY) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
            }.bind(that), 150);
        };

        //添加原型方法---设置用户按键,改变小蛇移动的方向
        Game.prototype.bindKey=function () {

            //获取用户的按键,改变小蛇的方向
            document.addEventListener("keydown",function (e) {
                //这里的this应该是触发keydown的事件的对象---document,
                //所以,这里的this就是document
                //获取按键的值
                switch (e.keyCode){
                    case 37:this.snake.direction="left";break;
                    case 38:this.snake.direction="top";break;
                    case 39:this.snake.direction="right";break;
                    case 40:this.snake.direction="bottom";break;
                }
            }.bind(that),false);
        };

        //把Game暴露给window,外部就可以访问Game对象了
        window.Game = Game;
    }());



    //初始化游戏对象
    var gm = new Game(document.querySelector(".map"));

    //初始化游戏---开始游戏
    gm.init();


    //外部测试代码
    //  var fd = new Food();
    //  fd.init(document.querySelector(".map"));
    //  //创建小蛇
    //  var snake = new Snake();
    //  snake.init(document.querySelector(".map"));//先在地图上看到小蛇
    //
    //
    //
    //  setInterval(function () {
    //    snake.move(fd, document.querySelector(".map"));
    //    snake.init(document.querySelector(".map"));
    //  }, 150);


    //  snake.move(fd, document.querySelector(".map"));//走一步
    //  snake.init(document.querySelector(".map"));//初始化---重新画一条小蛇(先删除之前的小蛇,把现在的小蛇显示出来)

    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));


    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //console.log(fd.x+"====>"+fd.y);

    //console.log(fd.width);



   */

    /*=======================原型以及原型链============================*/
    /*

        //使用对象---》使用对象中的数学和对象中的方法，使用对象就先要有构造函数
    //构造函数
    // function Person(name,age) {
    //     //属性
    //     this.name = name;
    //     this.age = age;
    //     this.sayHi = function () {
    //         console.log("您好，你真帅");
    //     };
    // }
    // //实例化对象，并且初始化
    // for (var  i = 0; i < 100; i++){
    //     var per = new Person("小明",20);
    //     per.sayHi();
    // }

    function Person(name,age) {
        //属性
        this.name = name;
        this.age = age;
        //在构造函数中的方法
        this.eat = function () {
          console.log("吃");
        };
        this.sayHi = function () {
            console.log("您好，你真帅");
        };
    }
    //增加共享的属性和方法
    Person.prototype.sex = "男";
    //增加共享的方法
    Person.prototype.sayHi = function () {
        console.log("您好厊");
    };
    //如果想要使用一些属性和方法，并且熟悉的值在每个对象中都是一样的，方法在每个对象中的操作也都是一样的，那么，为了我共享数据，节省空间，是可以把属性和方法通过原型的方法进行复制
    var per = new Person("小明",20);
    per.sayHi();

    console.dir(per);//实例对象的结构
    console.dir(Person);//构造函数的结构

    //实例对象的原型__proto__和构造函数的原型prototype指向是相同的

    //实例对象中的__proto__原型指向是构造函数中的原型prototype
    console.log(per.__proto__ == Person.prototype);
    //实例对象中__proto__是原型，浏览器中使用的，
    //构造函数中的prototype原型，是程序员用的



     */

    /*=========================原型的指向是否可以改变=====================================*/
    /*

        //构造函数中的this就是实例对象
    //原型对象中方法中的this就是这个实例对象
    // function Person(age) {
    //     this.age = age;
    //     console.log(this);
    // }
    // Person.prototype.eat = function () {
    //     console.log(this);
    //     console.log("您吃饭了么");
    // };
    // var per  = new Person(10);
    // per.eat();
    // console.log(per);


   //  function Student(age) {
   //      this.age = age;
   //      console.log(this);
   //  }
   //  Student.prototype.study = function () {
   //      console.log("学习");
   //  };
   //  Student.prototype = {
   //      eat:function () {
   //          console.log("好吃");
   //      }
   //  };
   // var stu = new Student();
   // stu.eat();


    //这是人的构造函数
    function Person(age) {
        this.age = 10;
        console.log(this);
    }
    //人的饿原型对象方法
    Person.prototype.eat = function () {
        console.log("吃饭🍚");
    };
    //学生的构造函数
    function Student(){
    }
    Student.prototype.sayHi = function(){
      console.log("嗨喽，我很帅的");
    };
    //学生的原型，指向了一个人的实例对象
    Student.prototype = new Person(10);
    var stu = new Student();
    stu.eat();
    //stu.sayHi();

    //原型指向可以改变
    //实例对象的原型__proto__指向是改对象所在的构造函数的原型对象
    //构造函数的原型对象（prrototype）指向如果改变了，实例对象的原型(__proto__)指向也会改变
    //原型的指向是可以改变的
    //实例对象和原型对象之间的关系是通过__proto__原型来联系起来的，这个关系就是原型链

     */

    /*=======================原型最终指向了哪里=======================================================*/
    /*

        function Person() {

    }
    Person.prototype.eat = function () {
        console.log("吃东西");
    };
    var per = new Person();
    console.dir(per);//实例对象
    console.dir(Person);//构造函数

    //实例对象中有__proto__原型
    //构造函数中有prototype原型
    //prototype是对象
    //所有prototype这个对象中也有__proto__原型，指向到哪里？
    //实例对象中的__proto__指向是构造函数的prototype
    //所有prototype这个对象中__proto__指向的应该是某个构造函数的原型prototype

    //Person的prototype
    console.log(Person.prototype.__proto__);

    //实例对象__proto__---》Person.prototype的__proto__---->Object.prototype的__proto__是null

    console.log(per.__proto__ == Person.prototype);
    console.log(per.__proto__.__proto__ == Person.prototype.__proto__);
    console.log(Person.prototype.__proto__ == Object.prototype);
    console.log(Object.prototype.__proto__);
     */

    /*====================原型指向改变如何增加方法和访问=================================================================*/
    /*

         // //人的构造函数
     //  function Person(age) {
     //      this.age = age;
     //  }
     //  //人的原型中添加方法
     //  Person.prototype.eat = function () {
     //      console.log("人吃东西");
     //  };
     //
     //  //学生的构造函数
     //  function Student(sex) {
     //      this.sex = sex;
     //  }
     //  //学生的原型中添加方法---先在原型中添加方法
     //  Student.prototype.sayHi = function () {
     //      console.log("您好啊")
     //  };
     //  //改变原型对象的指向
     //  Student.prototype = new Person(10);
     //
     //  var stu = new Student("男");
     //  stu.sayHi();//不能被访问
     //  stu.eat();







    // //人的构造函数
    // function Person(age) {
    //     this.age = age;
    // }
    //
    // //人的原型中添加方法
    // Person.prototype.eat = function () {
    //     console.log("人吃东西");
    // };
    //
    // //学生的构造函数
    // function Student(sex) {
    //     this.sex = sex;
    // }
    //
    // //改变原型对象的指向
    // Student.prototype = new Person(10);
    // //学生的原型中添加方法---先在原型中添加方法
    // Student.prototype.sayHi = function () {
    //     console.log("您好啊")
    // };
    // var stu = new Student("男");
    // stu.sayHi();//能被访问
    // stu.eat();
    // //一定要在原型对象之前添加方法
    // console.dir(stu);
    // //如果原型指向改变了。那么就应该在原型改变之后增加原型方法





    function Person(age) {
        this.age = age;
    }

    Person.prototype = {
        eat:function () {
            console.log("吃");
        }
    };
     //指向改变了。先添加方法，后改变指向，所有不能访问
     Person.prototype.sayHi = function () {
         console.log("您好");
     };
    var per  = new Person(10);
    per.sayHi();


     */

    /*=====================实例对象的属性和原型对象中的属性重名问题============================================*/
    /*

        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }
        Person.prototype.sex = "女";
        var per = new Person(10,"男");
        console.log(per.sex);
        console.dir(per);
        //以为js是一门动态类型的语言，对象没有什么，只要点了，那么这对象就有了这个东西，没有这个属性，只要对象.属性名字，对象就有这个属性了，但是，改属性没有复制，所以，结果就是：undefined
        console.log(per.nioononnin);


        //实例对象，访问这个属性，先从实例对象中找，找到了就直接用，找不到就去指向的原型对象中找，找到了就使用，找不到，就报错
        //通过实例对象能否改变原型对象中的属性值？不能
        per.sex = "人";
        console.log(per.sex);
        console.dir(per);


        //就是想要改变原型对象中的属性值怎么办？直接通过原型对象.属性 = 值；可以改变，如果找不到，就是undefined
        Person.prototype.sex = "我改变了";
        per.sex = "人";
        console.log(per.sex);
        console.dir(per);

     */

    /*=========================一个很神奇的原型链=================================*/
    /*


    <div id="dv"></div>

    //原型链：实例对象和原型对象之间的关系，通过__proto__来联系的

    var divObj = document.getElementById("dv");
    console.dir(divObj);

    //divObj.__proto__---->HTMLDivElement.prototype的__proto__----->指向的HTMLElement.prototype的__proto__----->指向的是Element.prototype的__proto__---->指向的是Node.prototype的__proto__---->指向是EventTarget.prototype的__proto---->指向Object.prototype没有__proto__没有
    //所以，prototype中的__proto__是null
     */

    /*============================继承========================================*/

    /*
    *
    * 面向对象编程思想:根据需求,分析对象,找到对象有什么特征和行为,通过代码的方式来实现需求,要想实现这个需求,就要创建对象,要想创建对象,就应该显示有构造函数,然后通过构造函数来创建对象.,通过对象调用属性和方法来实现相应的功能及需求,即可
    * 首先JS不是一门面向对象的语言,JS是一门基于对象的语言,那么为什么学习js还要学习面向对象,因为面向对象的思想适合于人的想法,编程起来会更加的方便,及后期的维护....
    * 面向对象的编程语言中有类(class)的概念(也是一种特殊的数据类型),但是JS不是面向对象的语言,所以,JS中没有类(class),但是JS可以模拟面向对象的思想编程,JS中会通过构造函数来模拟类的概念(class)
    *
    *
    *
    *
    * 小明,小红，小丽，小白，小花 都是人
    * 共同的特征和行为
    * 特征--->属性
    * 行为---方法
    *
    * 面向对象的特性:封装,继承,多态
    *
    * 封装:就是包装
    * 一个值存储在一个变量中--封装
    * 一坨重复代码放在一个函数中--封装
    * 一系列的属性放在一个对象中--封装
    * 一些功能类似的函数(方法)放在一个对象中--封装
    * 好多相类似的对象放在一个js文件中---封装
    *
    * 继承: 首先继承是一种关系,类(class)与类之间的关系,JS中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承
    * 继承也是为了数据共享,js中的继承也是为了实现数据共享
    *
    * 原型作用之一:数据共享,节省内存空间
    * 原型作用之二:为了实现继承
    *
    * 继承是一种关系:
    *
    * 父类级别与类级别的关系
    *
    * 例子:
    *
    * 小杨--->人, 姓名, 有钱, 帅, 有功夫--降龙十八掌
    * 小杨子-->人,
    * 继承:
    * 姓氏----继承
    * 外表----继承
    * 财产----继承
    * 功夫---继承
    *
    *
    * 人:  姓名, 性别, 年龄 ,吃饭, 睡觉
    *
    * 学生类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 学习行为
    * 老师类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资,教学行为
    * 程序员: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资, 敲代码
    * 司机类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资 开车
    *
    *
    * 动物类别:  体重， 颜色, 吃
    * 狗类别:   体重,颜色, 吃, 咬人
    * 二哈类别: 体重,颜色, 吃, 咬人 逗主人开心,汪汪,你好帅
    *
    *
    *
    *
    *
    *
    * 多态:一个对象有不同的行为,或者是同一个行为针对不同的对象,产生不同的结果,要想有多态,就要先有继承,js中可以模拟多态,但是不会去使用,也不会模拟,
    *
    *
    *
    *
    *
    * */


    /*
        //例子:
        //人,都有姓名,性别,年龄, 吃饭, 睡觉, 玩
        //学生,都有姓名,性别,年龄, 成绩, 吃饭, 睡觉, 玩 ,学习的行为


        //js中通过原型来实现继承

        function Person(name,age,sex) {
            this.name=name;
            this.sex=sex;
            this.age=age;
        }
        Person.prototype.eat=function () {
            console.log("人可以吃东西");
        };
        Person.prototype.sleep=function () {
            console.log("人在睡觉");
        };
        Person.prototype.play=function () {
            console.log("生活就是不一样的玩法而已");
        };

        function Student(score) {
            this.score=score;
        }
        //改变学生的原型的指向即可==========>学生和人已经发生关系
        Student.prototype=new Person("小明",10,"男");
        Student.prototype.study=function () {
            console.log("学习很累很累的哦.");
        };

        //相同的代码太多,造成了代码的冗余(重复的代码)

        var stu=new Student(100);
        console.log(stu.name);
        console.log(stu.age);
        console.log(stu.sex);
        stu.eat();
        stu.play();
        stu.sleep();
        console.log("下面的是学生对象中自己有的");
        console.log(stu.score);
        stu.study();

     */

    /*================================继承案例=======================================*/
    /*


        //动物有名字,有体重,有吃东西的行为
        //小狗有名字,有体重,有毛色, 有吃东西的行为,还有咬人的行为
        //哈士奇名字,有体重,有毛色,性别, 有吃东西的行为,还有咬人的行为,逗主人开心的行为


        //动物的构造函数
        function Animal(name,weight) {
            this.name=name;
            this.weight=weight;
        }
        //动物的原型的方法
        Animal.prototype.eat=function () {
            console.log("天天吃东西,就是吃");
        };

        //狗的构造函数
        function Dog(color) {
            this.color=color;
        }
        Dog.prototype=new Animal("哮天犬","50kg");
        Dog.prototype.bitePerson=function () {
            console.log("哼~汪汪~咬死你");
        };


        //哈士奇
        function ErHa(sex) {
            this.sex=sex;
        }
        ErHa.prototype=new Dog("黑白色");
        ErHa.prototype.playHost=function () {
            console.log("哈哈~咬坏衣服,咬坏桌子,拆家..嘎嘎...好玩,开心不,惊喜不,意外不");
        };
        var erHa=new ErHa("雄性");
        console.log(erHa.name,erHa.weight,erHa.color);
        erHa.eat();
        erHa.bitePerson();
        erHa.playHost();


     */


    /*=============================原型链==================================================*/



    /*=======================借用构造函数继承==============================*/
    /*    function Person(name,age,sex,weight) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.weight = weight;
        }
        Person.prototype.sayHi = function () {
            console.log("您好");
        };
        function student(score) {
          this.score = score;
        }
        //继承
        stu1dent.prototype = new Person("小明",10,"男","50kg");
        var stu1 = new stu1dent("100");
        console.log(stu1.name,stu1.age,stu1.weight,stu1.sex,stu1.score);
        stu1.sayHi();

        var stu2 = new stu1dent("120");
        stu2.name = "张三";
        stu2.sex = "女";
        stu2.age = "18";
        stu2.weight = "48kg";
        console.log(stu2.name,stu2.age,stu2.weight,stu2.sex,stu2.score);


        var stu3 = new student("130");
        console.log(stu3.name,stu3.age,stu3.weight,stu3.sex,stu3.score);
        stu3.sayHi();

        //为了数据共享，改变原型指向，做到了继承，---通过改变原型指向实现的继承
        //缺陷：因为改变原型指向的同时实现继承，直接初始化了属性，继承过来的属性的值都是一样的了，所有，这就是问题
        //只能重新调用对象.赋值就可以了*/





    /*
    //解决方法：继承的时候，不用改变原型的指向，直接调用父级的构造函数的方式来为属性赋值就可以了，----借用构造函数（把要继承的父级的构造函数拿过来，使用一下，就可以了）

    //借用构造函数：构造函数名字.call(当前对象,属性，属性，属性.... )
    //解决了属性继承，并且值不重复的问题
    //缺陷：父级类别中的方法不能继承

       function Person(name,age,sex,weight) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.weight = weight;
        }
        Person.prototype.sayHi = function () {
            console.log("您好");
        };
        function student(name,age,sex,weight,score) {
            //借用构造函数
            Person.call(this,name,age,sex,weight);
          this.score = score;
        }
        var stu1 = new student("小明",10,"男","10kg","100");
        console.log(stu1.name,stu1.age,stu1.weight,stu1.sex,stu1.score);

        var stu2 = new student("小红",20,"女","20kg","120");
        console.log(stu2.name,stu2.age,stu2.weight,stu2.sex,stu2.score);

        var stu3 = new student("小黄",30,"男","50kg","900");
        console.log(stu3.name,stu3.age,stu3.weight,stu3.sex,stu3.score);


   */

    /*==============================组合继承============================================================*/
    /*
        //原型继承
        //借用构造函数实现基础
        //组合继承：原型继承+借用构造函数基础



        function Person(name,age,sex) {
            this.name=name;
            this.age=age;
            this.sex=sex;
        }
        Person.prototype.sayHi=function () {
            console.log("阿涅哈斯诶呦");
        };
        function Student(name,age,sex,score) {
            //借用构造函数:属性值重复的问题
            Person.call(this,name,age,sex);
            this.score=score;
        }
        //改变了原型指向--可以实现基础
        Student.prototype = new Person();//不传值
        Student.prototype.eat = function () {
            console.log("吃东西");
        };
        var stu = new Student("小呗",20,"男","100分");
        console.log(stu.name,stu.age,stu.sex,stu.score);
        stu.sayHi();
        stu.eat();
        //属性和方法都被继承了
        var stu1 = new Student("小白",220,"男2","1200分");
        console.log(stu1.name,stu1.age,stu1.sex,stu1.score);
        stu1.sayHi();
        stu1.eat();

     */
    /*============================拷贝继承=====================================*/

    /*

        //拷贝继承：吧一个对象中的数学或者方法直接赋值到另外一个对象中
        // var obj1 = {
        //     name:"小糊涂",
        //     age:20,
        //     sleep:function () {
        //         console.log("睡觉");
        //     }
        // };
        //
        // //改变了地址的指向
        // var obj2 = obj1;
        // console.log(obj2.name,obj2.age);
        // obj2.sleep();






        // var obj1 = {
        //     name:"小糊涂",
        //     age:20,
        //     sleep:function () {
        //         console.log("睡觉");
        //     }
        // };
        // //改变了地址的指向
        // var obj2 = {};
        // for (var key in obj1){
        //     // obj2.name = obj1.name;
        //     // obj2.age = obj1.age;
        //     obj2[key] = obj1[key];
        // }
        // console.log(obj2.name,obj2.age);
        // obj2.sleep();


     */

    /*
    function Person() {

    }

    Person.prototype.age = 10;
    Person.prototype.sex = "男";
    Person.prototype.height = 100;
    Person.prototype.play = function () {
        console.log("好开心");
    };
    var obj2 = {};


    //Person的构造中有原型prototype，prototype就是一个对象，那么里面，age,sex,height,play都是该对象中的属性或者是方法

        for (var key in Person.prototype){
            obj2[key] = Person.prototype[key];
        }
        console.dir(obj2);
        obj2.play();
     */
    /*==========================继承=========================================*/


    //面向对象特征：封装，继承，多态
    //继承：类与类之间的关系，面向对象的语言继承，是为了多态服务的
    //js不是面向对象的语言，但是可以模拟面向对象，模拟继承，为了节省内存空间


    //继承：
    /**
     * 原型作用：数据共享，原型目的：为了节省内存空间
     * 原型作用：继承，节省内存空间
     *
     * 原型继承：改变原型指向
     * 借用构造函数继承：主要解决属性的问题
     * 组合继承：原型继承+借用构造函数继承
     * 组合继承既能解决属性问题，又可以解决方法问题
     * 拷贝继承：吧对象需要共享的属性和方法，直接遍历的方式复制到另一个对象中
     *
     */

    /*==============================逆推继承看原型=================================*/
    /*    function F1(age) {
            this.age = age;
        }
        function F2(age) {
            this.age = age;
        }
        F2.prototype = new F1(10);
        function F3(age) {
            this.age = age;
        }
        F3.prototype = new F2(20);

        var f3 = new F3(30);
        console.log(f3.age);*/


    /*=============================函数的角色及函数声明和函数表达式的区别============================================*/
    /*


    //函数的角色:
    //函数声明
    function f1() {
        console.log("我是函数");
    }
    f1();
    //函数表达式
    var ff = function () {
        console.log("我也是一个函数");
    };
    ff();

    */

    /*

        //函数声明
        // if (true){
        //     function f1() {
        //         console.log("哈哈，我很帅");
        //     }
        // } else {
        //     function f1() {
        //         console.log("嘻嘻，我很帅");
        //     }
        // }
        // f1();

        //函数表达式
        var ff;
        if(true) {
            ff = function () {
                console.log("哈哈，我很帅");
            }
        } else {
            ff = function () {
                console.log("嘻嘻，我很帅");
            }
        }
        ff();

        //函数声明如果放在if-else语句找你哥，在IE8的浏览器中会出现问题
        //以后宁愿用函数表达式，都不用函数声明
     */

    /*=================函数中的this和严格模式============================*/
    //函数中的this的指向
    //普通函数中this是谁？----------window
    //对象.方法中this是谁？----------当前的实例对象
    //定时器方法中的this是谁-----------window
    //构造函数的this-----------------实例对象
    //原型对象this-------------------实例对象

    /*
     //函数中的this的指向
     function f1() {
         console.log(this);
     }
     f1();
     //BOM：中顶级对象是window；浏览器所有的东西都是window
     //this是window
     */

    /*
    //定时器方法中的this是谁
    setInterval(function () {
        console.log(this);
    },1000)
    //this是window
     */

    /*

    //构造函数的this
     function Person() {
        console.log(this);
        this.sayHi = function () {
            console.log(this);
        };
    }
    Person.prototype.eat = function () {
          console.log(this);
    };
    var per = new Person();
    console.log(per);
    per.sayHi();
    per.eat();
    //this是实例对象
    //this是实例对象

     */


    /*

     //严格模式:
    "use strict";//严格模式
    function f1() {
        console.log(this);
    }
    window.f1();

     */

    /*========================函数的不同的调用方式==========================================*/
    /*
        //普通函数
        function f1() {
            console.log("文能提笔控萝莉")
        }
        f1();

        //构造函数---通过new 来调用，目的用来创建对象
        function F1() {
            console.log("我是构造函数");
        }
        var f = new F1();


        //对象的方法--对象.方法来调用的
        function Person() {
            this.play = function () {
                console.log("完");
            };
        }
        var per = new Person();
        per.play();

     */

    /*===================函数也是对象========================================*/
    /*

      //函数是对象，对象不一定是函数
        //对象中__proto__原型，是对象
        //构造函数有prototype原型，是对象
        // function F1() {
        // }
        // console.dir(F1);
        //
        //
        // console.dir(Math);//中有__proto__，但是没有prototype

        //对象中有__proto__,函数中应该有prototype

        //如果一个东西里面有prototype,又有__proto__，说明是函数，也是对象





        // function F2(name) {
        //     this.name = name;
        // }
        // console.dir(F2);
        //所有的函数实际上都是Function的构造函数创建出来的实例对象

        var f2 = new Function("num1","num2","return num1+num2");
        console.log(f2(10,20));

        //所有，函数实际也是对象
        console.dir(f2);

     */


    /*=======================数组中函数的调用==============================================================*/
    /*

        //数组中可以存储任何类型的数据
        var arr = [
            function () {
                console.log("放假了1");
            },
            function () {
                console.log("放假了2");

            },
            function () {
                console.log("放假了3");

            },
            function () {
                console.log("放假了4");

            },
        ];
        arr.forEach(function (ele) {
            ele();
        })

     */

    /*============================apply和call的方法======================================*/
    /*

        // apply和call的使用
    //作用：可以改变this的指向

    function f1(x,y) {
        console.log("结果是："+(x+y)+this);
        return "1000000";
    }
    f1(10,20);//函数的调用

    console.log("===========");
    //此时的f1实际上市当成对象来使用的，对象可以调用方法的
    //apply和call方法也是函数的调用的方式
    // f1.apply();
    // f1.call();
    console.log("===============");
    // f1.apply(null);
    // f1.call(null);

    //apply 和 call方法中如果没有传入参数，或者是传入的是Null,那么调用改方法的函数对象中的this就是默认的window

    f1.apply(null,[100,200]);
    f1.call(null,100,200);

    //apply 和call都可以让函数或者方法来调用，传入参数和函数自己调用的写法不一样，但是效果是一样的
    var result1 =  f1.apply(null,[1200,200]);
    var result2 = f1.call(null,1200,200);
    console.log(result1);
    console.log(result2);

    function f2(x,y) {
        console.log("这个函数window对象的一个方法"+(x+y)+this);//40[object Window]
    }
    window.f2(10,30);

    //obj是一个对象
    var obj = {
        age:10,
        sex:"男",
    };
    window.f2.apply(obj,[10,20]);//30[object Object]
    window.f1.call(obj,10,20);
    console.dir(obj);

    //apply和call可以改变this的指向

    function Person(age,sex) {
        this.age = age;
        this.sex = sex;
    }
    //通过原型添加方法
    Person.prototype.sayHi = function () {
        console.log("你好啊"+this.sex);
        return 1000;
    };
    var per = new Person(10,"男");
    per.sayHi();

    console.log("=======================");
    function Student(name,sex) {
        this.name = name;
        this.sex = sex;
    }
    var stu = new Student("小明","人妖");
    var r1 = per.sayHi.apply(stu,[10,20]);
    var r2 = per.sayHi.call(stu,10,20);
    console.log(r1);
    console.log(r2);

     */



    /*

        //apply和call都可以改变this的指向
    //函数的调用，改变this的指向
    function f1(x, y) {
        console.log((x + y) + ":===》" + this);
        return "这是函数的返回值";
    }

    //apply和call调用
    var r1 = f1.apply(null, [1, 2]);//此时f1中的this是window
    console.log(r1);

    //call调用
    var r2 = f1.call(null, 1, 2);//此时f1中的this是window
    console.log(r2);

    console.log("===============");
    //改变this的指向
    var obj = {
        sex : "男"
    };
    //本来f1函数是window的，但是传入obj，this就是object的了
    //apply调用
    var r1 = f1.apply(obj, [1, 2]);//此时f1中的this是object
    console.log(r1);

    //call调用
    var r2 = f1.call(obj, 1, 2);//此时f1中的this是object
    console.log(r2);

     */


    /*

    //    方法改变this的指向
    function Person(age) {
        this.age = age;
    }
    Person.prototype.sayHi = function (x,y) {
        console.log((x+y)+":====>"+this.age);//是实例对象
    };

    function Student() {

    }
    var per = new Person(10);//实例对象
    var stu = new Student();//实例对象
    //sayHi 方法是per实例对象的方法
    per.sayHi.apply(stu,[10,20]);
    per.sayHi.call(stu,10,20);


    //apply 和call的使用方法
    // apply的使用语法：
    // 函数名字.apply(对象,[参数1,参数2,....]);
    // 方法名字.apply(对象,[参数1,参数2,....]);
    //
    //call的使用语法：
    //函数名字.call(对象,参数1,参数2);
    //方法名字.call(对象,参数1,参数2);
    //
    //作用：改变this的指向
    //不用的地方：参数传递的方式是不一样的
    //只要是想使用别的对象的方法，并且希望这个方法是当前对象的，那么就可以使用apply或者是call的方法改变this的指向




     */


    /*=========================apply和call方法到底是谁的=========================================*/


    /*=============================bind的方法================================*/


    /*

        // function f1(x,y) {
    //     console.log((x+y)+":====>"+this);//30:====>[object Window]
    // }
    // f1(10,20);

    function f1(x,y) {
        console.log((x+y)+":====>"+this);//30:====>[object Window]
    }
    //复制了一份的时候，把一个参数传入到了f1函数中，x==>10,y===>20，null就是this,默认就是window
    // var ff = f1.bind(null,10,20);
    // ff();

    //bind方法是复制的意思，参数可以在复制的时候传进去，也可以在复制之后调用的时候传入
    var ff = f1.bind(null);
    ff(10,20);

     */


    /*

     //apply和call是调用的时候改变this的指向
        //bind方法，是复制一份的时候，改变this的指向

    function Person() {
        this.age = 1000;
    }

    Person.prototype.sayHi = function () {
        console.log("hey");
    };

    var per = new Person();

    var ff = f1.bind(per,10,20);
    ff();//30:====>[object Object]

     */


    /*

       function Person(age) {
       this.age = age;
   }
   Person.prototype.play = function () {
       console.log(this+":===>"+this.age);
   };

   function Student(age) {
       this.age = age;
   }
   var per = new Person(18);
    var stu = new Student(20);
    //复制了一份
    var ff =per.play.bind(stu);
    ff();


     */
    //bind是复制了一份
    //使用方法
    /*

        函数名字.bind(对象，参数1，参数2。。。。);---》返回值是复制之后的这个函数
        方法名字.bind(对象，参数1，参数2。。。。);----》返回值是复制之后的这个方法

     */

    /////////////////////////////////////////bind的使用
    /*    //通过对象，调用方法，产生随机数
        function ShowRandom() {
            this.number = parseInt(Math.random()*10+1);//1-10的随机数

        }
        //增加原型方法
        ShowRandom.prototype.show1  = function () {
            //改变了定时器中的this的指向了，本来应该是window,显示是实例对象了
            window.setInterval(this.show2.bind(this),1000);
        };
        ShowRandom.prototype.show2 = function () {
            //显示随机数
            console.log(this.number);
        };
        //实例对象
        var sr = new ShowRandom();
        //调用方法，输出随机数字
        //调用这个方法一次，不停产生随机数
        sr.show1();*/


    /*==========================函数中的几个成员==================================*/
    /*
        //函数中有一个name的属性---》函数的名字,name属性只读，不能改变函数的名字
        //函数中有一个arguments属性，---》实参的个数
        //函数中有一个length的属性----》函数定义的时候形参的个数
        //函数中有一个caller属性---》调用f1函数子在f2函数中调用，所有，此时调用者就是f2
        function f1(x,y) {
            console.log(f1.name);
            console.log(f1.arguments.length);//实参的个数
            console.log(f1.length);
            console.log(f1.caller);//调用者
        }
        f1.naem = "f5";
        f1(10,20);
        console.dir(f1);

        function f2() {
            console.log("f2代码");
            f1(1,2)
        }
        f2();

     */

    /*=============================函数作为参数使用=====================================*/
    /*

        function f1(fn) {
        console.log("f1的函数");
        fn();//此时fn当做是一个函数来使用
    }
    //fn是参数，最后作为函数使用了，函数是可以作为参数使用
    f1(function () {
        console.log("我是匿名函数");
    });
    //命名函数
    function f2() {
        console.log("f2的函数");
    }
    f1(f2);

    //函数作为参数的时候，如果是命名函数，那么只传入命名函数的名字，没有括号

     */

    /*


        //定时器中传入函数
        function f1(fn) {
            setInterval(function () {
                console.log("定时器开始");
                fn();
                console.log("定时器结束");
            },1000);
        }

        f1(function () {
            console.log("睡觉");
        })
     */


    /*============================函数作为返回值使用的小案例=======================================*/
    /*

        // function f1() {
        //     console.log("f1函数开始");
        //     return function () {
        //         console.log("我是函数，返回值来用的");
        //     }
        // }
        // var ff = f1();
        // ff();

        var num = 10;
        console.log(typeof  num);//获取num这个变量的数据类型
        var obj = {};//对象
        //判断这个对象是不是某个类型的
        console.log(obj instanceof Object);
        //此时输出的是Object的数据类型
        console.log(Object.prototype.toString());//[object Object]
        //数组的数据类型
        console.log(Object.prototype.toString.call([]));//[object Array]

        var arr = [10,20,30];
        console.log(Object.prototype.toString.call(arr));

        console.log(Object.prototype.toString.call(new Date()));

        //想要获取某个对象数据类型的样子
        // Object.prototype.toString.call(对象)，此时得到的就是这对象的类型的样子

        //获取某个对象的类型是不是你传入的类型
        //[10,20,30]，是不是[object Array]
        //type---是变量-----是参数---"[object array]"
        //obj----是变量-----是参数-----[10,20,30]
            //判断这个对象和传入的类型是不是同一个类型
        function getFun(type) {
            return function (obj) {
                return Object.prototype.toString.call(obj) ===  type;
            }
        }
        var ff =getFun("[object Array]");
        var result = ff([10,20,30]);
        console.log(result);

     */


    /*======================函数作为参数使用的练习铺垫========================================*/
    /*

       // var arr = [10,203,400,40,30,203,9,10];
        // //排序
        // arr.sort();
        // console.log(arr);

        // var arr = [10,203,400,40,30,203,9,10];
        // //排序---函数作为参数来使用，匿名函数，作为sort方法的参数使用，那么此时的匿名函数中，有两个参数
        // arr.sort(function (obj1,obj2) {
        //     if (obj1>obj2){
        //         return 1;
        //     }else if (obj1==obj2){
        //         return 0;
        //     }else {
        //         return -1;
        //     }
        // });
        // console.log(arr);


        // var arr = ["ewfwf","fgfrevv","fwfifrbiw","fudwifbuliuiwevhj"];
        // //排序---函数作为参数来使用，匿名函数，作为sort方法的参数使用，那么此时的匿名函数中，有两个参数
        // arr.sort(function (obj1,obj2) {
        //     if (obj1>obj2){
        //         return 1;
        //     }else if (obj1==obj2){
        //         return 0;
        //     }else {
        //         return -1;
        //     }
        // });
        // console.log(arr);



            //三部电影，电影名字，大小，上映时间
        function File(name,size,time) {
            this.name = name;
            this.size = size;
            this.time = time;
        }
        var f1 = new File("jack.avi","400M","1898-02-20");
        var f2 = new File("jack2.avi","300M","2018-02-20");
        var f3 = new File("jack3.avi","200M","1999-02-20");

        var arr = [f1,f2,f3];

        function fn(attr) {
            return  function getSort(obj1,obj2) {
                if (obj1[attr]>obj2[attr]){
                    return 1;
                }else if(obj1[attr] == obj2[attr]){
                    return 0;
                }else {
                    return -1;
                }
            }
        }

        var ff = fn("size");


        arr.sort(ff);
        for (var i = 0; i<arr.length;i++){
            console.log(arr[i].name + "=====>"+arr[i].size+"====>"+arr[i].time);
        }


     */

    /*==============================作用域和作用域链和预解析==================================*/

    /*

    //变量----》局部变量和全局变量
    //作用域--》就是变量使用的范围
    //局部作用域和全局作用域
    //js中没有块级作用域：---一对大括号中定义的变量，这个变量可以在大括号外面使用
    //函数中定义的变量是局部变量

    // while (true){
    //     var num = 10;
    //     break;
    // }
    // console.log(num);//10
    //
    //
    // {
    //     var num1 = 100;
    // }
    // console.log(num1);
    //
    //
    // if (true){
    //     var num3 = 1000;
    // }
    // console.log(num3);
    //
    //
    // function f1() {
    //     var num4 = 10000;
    // }
    // console.log(num4);//这个是局部变量，是不能在外面访问的

     */

    /*

    //作用域链：变量的使用，从里向外，层层的搜索，搜索到了就可以直接使用了
    //层层搜索，搜索到0级作用域的时候，如果还没有找到这个变量，结果就是报错
    var num= 10;//作用域：级别0
    function f1() {
        var num = 20;//作用域：级别1
        function f2() {
            var num = 30;//作用域：级别2
            console.log(num);
        }
        f2();
    }
    f1();

     */


    /*



    //预解析：就是在浏览器解析代码之前，把变量的声明和函数的声明提前(提升),到该作用域的最上面

    //变量的提升
    console.log(num);
    var num = 100;

    //函数的声明被提前了
    f1();
    function f1() {
        console.log("这个函数执行了");
    }

    //变量提前声明是undefined，undefined()，是报错的
    // f2();
    // var f2 = function () {
    //     console.log("这个函数执行了11");//报错了
    // };
    //
    //---》修改的代码
    var f2;
     f2 = function () {
        console.log("这个函数执行了22");
    };
    f2();


     */


    /*==============================闭包====================================*/

    //闭包
    /**
     *
     * 闭包的概论：函数A中，有一个函数B中可以访问函数A中定义的变量或者是数据，此时形成了闭包（这句话暂时不严谨）
     * 闭包的模式：函数模式的闭包，对象模式的闭包
     * 闭包的作用：缓存数据，延长作用域链
     * 闭包的有点和缺点：缓存数据
     * 闭包的应用：
     *
     *
     */

    /*
        //函数模式的闭包，在函数中有一个函数
        function f1() {
            var num = 10;
            //函数声明
            function f2() {
                console.log(num);
            }
            //函数调用
            f2();
        }
        f1();

        //对象模式的闭包:函数中有一个对象
        function f3() {
            var num = 10;
            var obj = {
                age : num
            };
            console.log(obj.age);
        }
        f3();
    */

    /*

    function f1() {
            var num = 10;
            return function () {
                console.log(num);
                return num;
            }
        }

        var ff = f1();
        var result = ff();
        console.log(result);

     */


    // function f2() {
    //     var num = 200;
    //     return {
    //         age : num
    //     }
    // }
    // var ff =f2();
    // console.log(ff.age);


    // function f1() {
    //     var num = 10;
    //     num++;
    //     console.log(num);
    // }
    // f1();//11
    // f1();//11
    // f1();//11


    // function f1() {
    //     var num = 10;
    //     return function () {
    //         num++;
    //         return num;
    //     }
    // }
    // var ff = f1();
    // console.log(ff());//11
    // console.log(ff());//12
    // console.log(ff());//13

    /*================================闭包案例产生相同的随机数=============================================*/
    /*

    // function showRandom() {
        //     var num = parseInt(Math.random()*10+1);
        //     console.log(num);
        // }
        // showRandom();
        // showRandom();
        // showRandom();

        //闭包的方式：产生三个随机数，但是都是相同的
        function f1() {
            var num = parseInt(Math.random()*10+1);
            return function () {
                console.log(num);
            }
        }
        var ff = f1();
        ff();
        ff();
        ff();
        //总结：如果想要缓存数据，就把数据放在外层的函数和里层的函数的中间位置
        //闭包的作用：缓存数据,优点也是缺点，没有及时的释放
        //局部变量在函数中，函数使用结束后，里面的局部变量就会被自动释放
        //闭包后，里面的局部变量的使用作用域就会被延长

     */

    /*==========================闭包点赞========================================*/
    /*

        ul {
      list-style-type: none;
    }

    li {
      float: left;
      margin-left: 10px;
    }

    img {
      width: 200px;
      height: 180px;
    }

    input {
      margin-left: 30%;
    }
  </style>

</head>
<body>
<ul>
  <li><img src="images/ly.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
  <li><img src="images/lyml.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
  <li><img src="images/fj.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
  <li><img src="images/bd.jpg" alt=""><br/><input type="button" value="赞(1)"></li>
</ul>
<script>
  //获取所有的按钮
  function my$(tagName) {
    return document.getElementsByTagName(tagName);
  }
  //闭包
  function getValue() {
    var value = 1;
    return function () {
      // value++;
      this.value = "赞("+(value++)+")";
    }
  }
  var btnObj = my$("input");
  for (var i = 0; i<btnObj.length;i++){
    btnObj[i].onclick = getValue();
  }

  // value = 1;
  // var btnObj =my$("input");
  // for (var i = 0; i<btnObj.length;i++){
  //   btnObj[i].onclick = function () {
  //     this.value = "赞("+(value++)+")";
  //   };
  // }

     */


    /*============================沙箱===========================================*/
    /*

        //沙箱：环境，黑盒，在一个虚拟的环境中模拟真实的世界，做实验，实验结果和真实世界的结果是一样的，但是不会影响到真实的世界
        var num = 100;
        (function () {
            var num = 10;
            console.log(num);//10
        })();
        console.log(num);//100


        // var str = "小白喜欢吃";
        //
        // (function () {
        //     var str="小红喜欢玩";
        //     str = str.substr(2);
        //     console.log(str);
        // })();
        // str = str.substr(2);
        // console.log(str);

     */

    /*


    <div>这是div</div>
    <div>这是div</div>
    <div>这是div</div>
    <p>这是p</p>
    <p>这是p</p>
    <p>这是p</p>




    <script>
        //沙箱：环境，黑盒，在一个虚拟的环境中模拟真实的世界，做实验，实验结果和真实世界的结果是一样的，但是不会影响到真实的世界
        // var num = 100;
        // (function () {
        //     var num = 10;
        //     console.log(num);//10
        // })();
        // console.log(num);//100


        // var str = "小白喜欢吃";
        //
        // (function () {
        //     var str="小红喜欢玩";
        //     str = str.substr(2);
        //     console.log(str);
        // })();
        // str = str.substr(2);
        // console.log(str);

        var getTag = 10;
        var dvObj = 20;
        var dvObj1 = 30;

        (function () {
            function getTag(tagName) {
                return document.getElementsByTagName(tagName);
            }
            var dvObj = getTag("div");
            for (var i = 0; i<dvObj.length;i++){
                dvObj[i].style.border = "2px solid red";
            }

            var dvObj1 = getTag("p");
            for (var i = 0; i<dvObj1.length;i++){
                dvObj1[i].style.border = "2px solid pink";
            }
        })();



        console.log(getTag);
        console.log(dvObj);
        console.log(dvObj1);


    */



    /*============================递归============================================*/
    /*

        //递归：就是函数中调用函数自己，此时就是递归，递归一定要有结束条件
    var i = 0;
      function f1() {
          i++;
          if (i<5){
              f1();
          }
        console.log("我帅啦");
      }
      f1();




          //递归案例求n个数字的累加和

    //之前写法：
    // var num = 10;
    // for (var i = 0; i<= 5; i++){
    //     num += i;
    // }
    // console.log(num);

    //递归写法：n+5-->5+4+3+2+1
    function getSum(x) {
        if (x == 1){
            return 1;
        }
        return x+getSum(x-1);
    }

    console.log(getSum(5));

    //代码执行getSum(5)---->进入函数，此时的x是5，执行的是5+getSum(4)，此时代码等待
    //此时的5+getSum(4)，代码先不进行计算，先执行getSum(4)，进入函数，执行的是4+getSum(3)，
    //等待，先执行getSum(3)，进入函数，执行3+getSum(2)，.。。。。。。。。




    //递归案例-----求一个数字各个位数上的数字的和：123--》1+2+3=6
    function getSum(x) {
        if (x<10){
            return x;
        }
        //获取的是这个数字的个位数
        return  x%10 + getSum(parseInt(x/10));
    }
    console.log(getSum(11311));

    //递归案例-----求斐波那数列
    function  getFb(x) {
        if (x==1||x==2){
            return 1;
        }
        return getFb(x-1)+getFb(x-2);
    }
    console.log(getFb(12));

     */

    /*============================浅拷贝=========================================*/
    /*

        //浅拷贝：就是复制，就是相当于吧一个对象中的所有的内容，复制一分给另外一个对象，直接复制，或者说，就是把一个对象的地址给了另外一个对象，他们指向相同
        //       两个对象直接有共同的属性和方法，都是可以使用

        var obj1 = {
            age:10,
            sex:"男",
            car:["奔驰","宝马","特斯拉","奥拓"]
        };
        //另一个对象
        var obj2 = {};
        //obj2["age"] = obj1.age;
        //写一个函数，作为：吧一个对象的数学复制到另外一个对象中，浅拷贝
        //吧a对象中的所有的属性复制到对象b中
        function extend(a,b) {
            for (var key in a){
                b[key] = a[key];
            }
        }
        extend(obj1,obj2);
        console.dir(obj2);//开始的时候，是空对象
        console.dir(obj1);//有属性的

     */


    /*============================深拷贝==========================================*/
    /*

        //深拷贝：拷贝就是复制，深：就是吧一个对象中所有的属性或者方法，一个一个的找到，并且在另一个对象中开辟相应的空间，一个一个的存储到另外一个对象中

        var obj1 = {
            age:10,
            sex:"男",
            car:["奔驰","宝马","特斯拉","奥拓"],
            dog:{
                name:"小白",
                age:5,
                color:"白色"
            }
        };
        var obj2 = {};

        //通过函数实现，把对象a中的所有的数据深拷贝到对象b中
        function extend(a,b) {
            for (var key in a){
                //先获取a队长中每个属性的值
                var item = a[key];
                //判断这个属性的值是不是数组
                if (item instanceof  Array){
                    //如果是数组，那么在b对象中添加一个新的属性,并且这个属性值也是数组
                    b[key]=[];
                    //调用这个方法，把a对象中这个数组的属性值，一个一个的复制到b对象的这个数组属性中
                    extend(item,b[key]);
                }else if(item instanceof Object){//判断这个值是不是对象类型的
                    b[key]={};
                    extend(item,b[key]);
                }else {
                    b[key] = item;
                }
            }
        }
        extend(obj1,obj2);
        console.dir(obj1);
        console.dir(obj2);

     */


    /*==========================遍历dom树=====================================*/
    /*


    <h1>遍历 DOM 树</h1>
    <p style="color: green;">Tip: 可以在遍历的回调函数中任意定制需求</p>
    <div>
        <ul>
            <li>123</li>
            <li>456</li>
            <li>789</li>
        </ul>
        <div>
            <div>
                <span>haha</span>
            </div>
        </div>
    </div>
    <div id="demo_node">
        <ul>
            <li>123</li>
        </ul>
        <p>hello</p>
        <h2>world</h2>
        <div>
            <p>dsa</p>
            <h3>
                <span>dsads</span>
            </h3>
        </div>
    </div>
    <script>

        //获取页面中的根节点--根标签
        var root=document.documentElement;//html
        //函数遍历DOM树
        //根据根节点,调用fn的函数,显示的是根节点的名字
        function forDOM(root1) {
            //调用f1,显示的是节点的名字
            // f1(root1);
            //获取根节点中所有的子节点
            var children=root1.children;
            //调用遍历所有子节点的函数
            forChildren(children);
        }
        //给我所有的子节点,我把这个子节点中的所有的子节点显示出来
        function forChildren(children) {
            //遍历所有的子节点
            for(var i=0;i<children.length;i++){
                //每个子节点
                var child=children[i];
                //显示每个子节点的名字
                f1(child);
                //判断child下面有没有子节点,如果还有子节点,那么就继续的遍历
                child.children&&forDOM(child);
            }
        }
        //函数调用,传入根节点
        forDOM(root);
        function f1(node) {
            console.log("节点的名字:"+node.nodeName);
        }

        //节点:nodeName,nodeType,nodeValue




        //  第一个函数:给我根节点,我会找到所有的子节点:forDOM(根节点)
        //  获取这个根节点的子节点
        //  var children=根节点的.children
        //  调用第二个函数
        //
        //  第二个函数:给我所有的子节点,我把每个子节点的名字显示出来(children)
        //  for(var i=0;i<children.length;i++){
        //    每个子节点
        //    var child=children[i];
        //    f1(child);给我节点,我显示该节点的名字
        //    child是子节点,但是如果child里面还有子节点,此时child就是爹了
        //    child.children&&第一个函数(child)
        //
        //  }







     */

    /*========================正则表达式========================================*/
    /**
     * 正则表达式：也叫做规则表达式，安装一定的规则组成一个表达式，这个表达式的作用主要是匹配字符串的，
     * "我的电话号：10086"，正则表达式，吧这个字符串中的所有的数字找到
     * 正则表达式的作用：匹配字符串的
     * 大多数编程语言中都可以使用的
     * 正则表达式的组成：是由元字符或者是限定符组成的一个式子
     * 元字符：
     * .  表示的是：除了\n以外的任意的一个字符
     * [] 表示的是一个范围，[0-9]，表示的是0-9之间的任意的一个数字    [1-7] 表示的是1-7之间的任意的一个数字，      [100-200] 错误的表示
     *         1[0][0]:这个就是100      ； 1[0-9][0-9]  ，这个是100-199之间的任意的数字
     * [a-z]  表示的是：所有的小写的字母中的字母中的任意一个
     * [A-Z]  表示的是：所有的大写的字母中的字母中的任意一个
     * [a-zA-Z] 表示的是：所有的字母的任意一个
     * [0-9a-zA-Z] 表示的是：所有的数字或者是字母
     * [] 另外一个含义：把正则表达式中的元字符的意义干掉 [.] 就是一个.
     * | 表示的是： 或者           例子： [0-9]|[a-z] 表示的是：要么的是一个数字，要么是一个小写的字母
     * ()表示的是分组 ，提高优先级      [0-9]|([a-z])|[A-Z]
     * ([0-9])([1-5])([a-z]) 三组：从最左边开始计算
     *
     *  都是元字符，但是也可以叫限定符，下面的这些都是：
     *     * 表示的是：前面的表达式出来了0次到多次     [a-z][0-9]*  表示的是：小写字母中的任意一个，后面要么是没有数字，要么是多个数字
     *     + 表示的是：前面的表达式出现了1次到多次
     *                [a-z][9]+ 小写字母一个后面最少是一个9，或者多个9
     *     ？表示的是：前面的表达式出现了0次到1次，最少是0次，最多是1次,另一个含义：阻止贪婪模式
     *                [4][a-z]?
     *
     *  限定符：限定前面的表达式出来的次数
     *   {}更加的明确前面的表达式出现的次数
     *     {0,} 表示的是前面的表达式出现了0次到多次，和 * 一样的
     *     {1,} 表示的是前面的表达式出来了1次到多次，和 + 一样的
     *     {0,1} 表示的是前面的表达式出现了0次到1次，和 ? 一样的
     *     {5,10} 表示前面的表达式出现了5-10次
     *     {4} 表示的是出现了4次
     *     {,10}错误的写法----======错误的
     *
     *     ^ 表示的是：以开始，或者是取非(取反)，^[0-9] 以数字开头
     *               ^[a-z] 以小写的字母开始
     *     [^0-9]  取反  这个的意思是说：非数字
     *     [^a-z] 非小写字母
     *     [^0-9a-zA-Z] 就是特殊符号
     *     $ 表示的是：以什么结束，
     *               [0-9][a-z]$  表示的是必须以小写字母结束
     *
     *     ^& 相当于是严格模式,开始是^ ，结束是&
     *     ^[0-9][a-z]& 相当于是严格模式  必须是一个数字一个字母  "3a"
     *                  [0-9][a-z]   不严格模式："45543nibnuik" 这样都是可以的
     *                  [0-9][a-z]&  "12432432e"  这样都是可以的
     *
     *     \d 数字中的任意一个
     *     \D 非数字中的一个
     *     \s 空白符号
     *     \S 非空白符
     *     \w 非特殊符号
     *     \W 特殊符号
     *     \b 单词的边界
     *     \" 转义
     */
    /*================================正则表达式练习========================================*/
    //写正则表达式，根据字符串来写正则表达式进行匹配、
    /**
     * 经验：
     *     找规律，不要追求完美
     *
     * 身份证的正则表达式：15位或者18位
     *                  ([1-9][0-9]{14})|([1-9][0-9]{16}[0-9xX])
     *                  简化：([1-9][0-9]{14}])([0-9]{2}[0-9xX])?
     *
     *  座机电话号码的正则表达式：010-19876754     0825-12345687
     *                      \d{3,4}[-]\d{8}或者是[0-9]{3,4}[-][0-9]{8}
     *
     *  qq号码的正则表达式：[1-9][0-9]{4,10} 或者是  \d{5-11}
     *
     *  手机号码的正则表达式验证：
     *             130  131  132 133  134 135 136 137 138 139
     *             147  143
     *             150  151  152  153 154 156 157  158 159  159
     *             170  171  173  176   177
     *             180  181  182  184   185  186  188  189
     *             199
     *
     *             ([1][358][0-9][0-9]{8})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8}|([1][9][9][0-9]{8}))
     *
     *  邮箱的正则表达式：
     *              [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]){1,2}
     */

    /*============================正则表达式创建对象=========================================*/

    /**
     * 两种：
     *
     * 1.通过构造函数创建对象
     * 2.字面量的方式创建对象
     *
     *
     */
    /*

    // var reg = new RegExp(/^\d{5}&/);//对象创建完毕
    // var str = "我的电话是10086";
    // var flag = reg.test(str);
    // console.log(flag)

    // var reg = new RegExp(/^\d{5}&/);//对象创建完毕
    // var flag = reg.test("10086");
    // console.log(flag)

    //字母量创建
    var reg = /^\d{5}$/;
    reg.test("10086");
    console.log(reg.test("10086"));

 */


    /*==========================密码强度============================*/
    function my$(id) {
        return document.getElementById(id);
    }

    /*
      *
      * 密码: 数字,字母,特殊符号
      *
      * 密码: 只有数字- 或者是只有字母,或者是只有特殊符号---1级---弱
      * 两两组合: 数字和字母, 数字和特殊符号, 字母和特殊符号   -----2级----中
      * 三者都有: 数字和字母和特殊符号------3级-----强
      *
      * */
    /*

      //获取文本框注册键盘抬起时间
      my$("pwd").onkeyup = function () {
        //每次键盘抬起都要获取文本框中内容，验证文本框找你哥有什么内容，得到一个级别，然后下面的div显示对应的颜色
        //密码长度小于6 ，是没有必要判断
        if (this.value.length>=6){
          var lv = getLV(this.value);
          if (lv == 1){
            my$("strengthLevel").className = "strengthLv1"
          }else if (lv==2){
            my$("strengthLevel").className = "strengthLv2"
          }else if (lv==3){
            my$("strengthLevel").className = "strengthLv3"
          }else {
            my$("strengthLevel").className = "strengthLv0"
          }
        }else {
          my$("strengthLevel").className = "strengthLv0"
        }

      };
      //给我密码返回对应的级别
      function getLV(pwd) {
        var lv = 0;
        if (/[0-9]/.test(pwd)){
          lv++;
        }
        //判断密码中有没有字母
        if(/[a-zA-Z]/.test(pwd)){
          lv++;
        }
        //判断特殊符号
        if (/[^0-9a-zA-Z_]/.test(pwd)){
          lv++;
        }

        return lv;

      }

    */





    /*
        //获取文本框注册键盘抬起时间
        my$("pwd").onkeyup = function () {
            //每次键盘抬起都要获取文本框中内容，验证文本框找你哥有什么内容，得到一个级别，然后下面的div显示对应的颜色
            //密码长度小于6 ，是没有必要判断
            //   if (this.value.length>=6){
            //     var lv1 = getLV(this.value);
            //     my$("strengthLevel").className = "strengthLv"+lv1;
            //   }else {
            //     my$("strengthLevel").className = "strengthLv0";
            //   }
            //
            my$("strengthLevel").className="strengthLv"+(this.value.length >= 6?getLV(this.value):0);

        };
        //给我密码返回对应的级别
        function getLV(pwd) {
            var lv1 = 0;
            if (/[0-9]/.test(pwd)){
                lv1++;
            }
            //判断密码中有没有字母
            if(/[a-zA-Z]/.test(pwd)){
                lv1++;
            }
            //判断特殊符号
            if (/[^0-9a-zA-Z_]/.test(pwd)){
                lv1++;
            }

            return lv1;

        }*/
    /*===============================验证邮箱==============================================*/
    /*

        请您输入邮箱地址 <input type="text" value="" placeholder="email" id="email"> *
    </div>


        //获取文本框
        document.getElementById("email").onblur = function () {
            //判断文本框是不是邮箱
            var reg = /^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}$/;
            if (reg.test(this.value)){
                this.style.backgroundColor = "green";
            }else {
                this.style.backgroundColor = "red";
            }
        }
        //获取光标的颜色


     */

    /*=====================================案例验证中文名字=====================*/

    /*

    请您输入名字：<input type="text" value="" id="username"> *
<script>

    //escape("做我的女朋友好不好，不好下次再来问你");
    //unescape("%u505A%u6211%u7684%u5973%u670B%u53CB%u597D%u4E0D%u597D%uFF0C%u4E0D%u597D%u4E0B%u6B21%u518D%u6765%u95EE%u4F60")


    document.getElementById("username").onblur = function () {
        var reg = /^[\u4e00-\u9fa5]{2,6}$/;
        if (reg.test(this.value)){
            this.style.backgroundColor = "green";
        }else {
            this.style.backgroundColor = "red";
        }
    }

    */

    /*=====================================大项目验证表单=====================*/

    /*

        body {
          background: #ccc;
        }

        label {
          width: 40px;
          display: inline-block;
        }

        span {
          color: red;
        }

        .container {
          margin: 100px auto;
          width: 400px;
          padding: 50px;
          line-height: 40px;
          border: 1px solid #999;
          background: #efefef;
        }

        span {
          margin-left: 30px;
          font-size: 12px;
        }

        .wrong {
          color: red
        }

        .right {
          color: green;
        }

        .defau {
          width: 200px;
          height: 20px;
        }

        .de1 {
          background-position: 0 -20px;
        }
      </style>

    </head>

    <body>
    <div class="container" id="dv">
      <label for="qq">Q Q</label><input type="text" id="qq"><span></span><br/>
      <label for="phone">手机</label><input type="text" id="phone"><span></span><br/>
      <label for="e-mail">邮箱</label><input type="text" id="e-mail"><span></span><br/>
      <label for="telephone">座机</label><input type="text" id="telephone"><span></span><br/>
      <label for="fullName">姓名</label><input type="text" id="fullName"><span></span><br/>
    </div>
    <script>
      function my$(id){
        return document.getElementById(id);
      }

      //qq的
      checkInput(my$("qq"),/^\d{5,11}$/);
      //手机
      checkInput(my$("phone"),/^\d{11}$/);
      //邮箱
      checkInput(my$("e-mail"),/^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}$/);
      //座机号码
      checkInput(my$("telephone"),/^\d{3,4}[-]\d{7,8}$/);
      //中文名字
      checkInput(my$("fullName"),/^[\u4e00-\u9fa5]{2,6}$/);
      //给我文本框,给我这个文本框相应的正则表达式,我把结果显示出来
      //通过正则表达式验证当前的文本框是否匹配并显示结果
      function checkInput(input,reg) {
        //文本框注册失去焦点的事件
        input.onblur=function () {
          if(reg.test(this.value)){
            this.nextElementSibling.innerText="正确了";
            this.nextElementSibling.style.color="green";
          }else{
            this.nextElementSibling.innerText="让你得瑟,错了吧";
            this.nextElementSibling.style.color="red";
          }
        };
      }

     */

    /*=============================字符串中使用正则表达式的方法================================================*/
    /* //正则表达式中:g，表示的是全局匹配模式
      //正则表达式：i:表示忽略大小写
  var str = "中国移动：10086，中国联通：10010，中国电信：10000";
  var array = str.match(/\d{5}/g);
  console.log(array);*/

    /* //提取这里的日
     var str = "2017-11-11";
     var array =str.match(/(\d{4})[-](\d{2})[-](\d{2})/g);
     console.log(RegExp.$1);
  */


    /*var email = "itwangyang@gmail.com";
    var array = email.match(/([0-9a-zA-Z._-]+)[@]([0-9a-zA-Z._-]+)(([.][a-zA-Z]+){1,2})/);
      console.log(RegExp.$1);
      console.log(RegExp.$2);
      console.log(RegExp.$3);*/


    /*
      var str = "我真的好帅，太帅了,帅就是真的帅";
      str = str.replace(/帅/g,"猥琐");
      console.log(str);
    */


    /*
        // var str = "        我的天啦     ，你好";
        // str = str.trim();
        // console.log("====="+str+"====");
       var str = "        我的天啦     ，你好";
       str = str.replace(/\s/g,"");
       console.log("====="+str+"====");*/



    /*   var str = "HhTTppS";
       str = str.replace(/[h]/gi,"s");
       console.log(str);

   */


    /*   var reg = new RegExp(/[h]/gi);
       var str = "HhTTppS";
       str = str.replace(reg,"s");
       console.log(str);*/


    /*    var str = "中国移动：10086，中国联通：10010，中国电信：10000";
        var reg = /\d{5}/g;
        // console.log(array);
        // console.log(reg.exec(str));
        // console.log(reg.exec(str));
        var arr = reg.exec(str);
        while (arr != null) {
            console.log(arr[0]);
            arr = reg.exec(str);
        }*/
/*==========================真数组还是伪数组====================================*/
    /*
    //真数组长度是可以变的，
    // 伪数组是不可变的
    //真数组可以使用数组中的方法
    //伪数组不可以使用数组方法的


    //数组
    var arr = [10,20,30];
    //对象---假数组
    var obj = {
        0:10,
        1:20,
        3:30,
        length:3
    };
    // for (var i = 0; i<arr.length; i++){
    //     console.log(arr[i]);
    // }

    // for (var i = 0; i<obj.length; i++){
    //     console.log(obj[i]);
    // }

   /!* function f1() {
        var sum= 0;
        for (var i = 0; i < arguments.length;i++){
            sum+=arguments[i];
        }
        //arguments得到的是实参的个数以及实参的值
        console.log(sum);
    }
    f1(10,2 ,10,30);*!/


    // function f1() {
    //     var sum= 0;
    //     arguments.forEach(function () {
    //
    //     });
    //     console.log(sum);
    // }
    // f1(10,2 ,10,30);



    // var arr = [10,20,30];
    // arr.forEach(function () {
    //
    // })

    var arr = [10,20,30];
    arr.forEach();
    console.dir(arr);//这个数组就实例对象，实例数组对象的__proto__---》Array的prototype



*/

</script>
</html>