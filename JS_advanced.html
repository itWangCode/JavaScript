<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <link rel="stylesheet" href="">
</head>
<body>

</body>
<script type="text/javascript">
    /*==================================创建对象的三种方式===================================*/
    /*

       //对象：特值的某个事物，具有属性和方法（一组无序的属性的集合）
        //特征---》属性
        //行为---》方法
        //小汪--》姓名,性别，年龄，吃，睡觉，玩

        //创建对象三种方式：
    //    1.字面量的
    //    2.调用系统的构造函数
    //    3.自定义构造函数方式


        //字面量
        var per1 = {
           name:"xixi",
           age:20,
            sex:"男",
             eat:function () {
                 console.log("吃饭");
             },
            readBook:function () {
                console.log("散文诗歌");
            }
        };

        //调用系统函数的构造函数
        var per2 = new Object();
        per2.name = "haha";
        per2.age = 18;
        per2.sex = function () {
            console.log("吃榴莲")
        };
        per2.play = function () {
            console.log("真好玩")
        };
        function Person(){

        }
        //console.log(per2 instanceof Person)
        console.log(per2 instanceof Object);


    //自定义构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;

            this.play = function () {
                console.log("好玩");
            };
        }
        var per =  new Person("汪程序员",19,"女");
        console.log(per instanceof Person);
        console.log(per);
     */

    /*==================================自定义构造函数创建对象做的事情================================================*/
    /*


        function Person(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.play = function () {
            console.log("跑步");
        };
    }
    //创建对象---》实例化一个对象的同时对属性进行初始化
    var per = new Person("小汪",18,"男");
    console.log(per);

*/
    /*
    * 1.开辟空间存储对象
    * 2.把this设置当前的对象
    * 3.设置属性和方法的值
    * 4.把this对象返回
    * */
    /*============================工厂模式=====================================*/
    /*

        // 工厂模式创建对象
    function createObject(name,age) {
        var  obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.sayHi = function () {
            console.log("你好");
        };
        return obj;
    }

    var per = createObject("小汪",19);
    console.log(per);
     */


    /*
    *  自定义构造函数与工厂模式
    *  共同点：都是函数，都可以创建对象，都可以传入参数
    *
    *  工厂模式：函数名是小写,
    *           有new，有返回值
    *           new之后对象是当前的对象
    *           直接调用函数就可以创建对象
    *
    *
    *  自定义构造函数：函数名首字母是大写的，
    *               没有new，没有返回值
    *               this是当前的对象
    *               通过new的方式创建对象的
    *
    *
    * */


    /*=======================构造函数和实例对象之间的关系=======================================*/
    /*

       //面向对象的思想是------抽象的过程----实例化的过程
        //我这个人：姓名，年龄，性别，吃饭，打招呼，睡觉。。。
        //自定义构造函数---实例化对象
        //这是构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.sayHi = function () {
                console.log("hello");
            };
            this.sleep = function () {
                console.log("sleep")
            };
            this.eat = function () {
                console.log("吃");
            }
        }//构造函数end


        //构造函数---》创建对象
        var per = new Person("汪洋",28,"男");
        per.eat();
        //实例对象是通过构造函数来创建
        //实例对象会指向自己的构造函数（暂时理解，是错误的）


        console.dir(per);//把这个对象的结构显示出来
        console.dir(Person);
        //实例对象的构造器是指向Person的，结构是true，所以，这个实例对象per就是通过Person来创建的
        console.log(per.constructor==Person);//true   //实例对象的构造器（构造函数）
        console.log(per.__proto__.constructor==Person);//true
        console.log(per.__proto__.constructor == Person.prototype.constructor);//true

        //构造函数
        function Animal(name) {
            this.name = name;
        }
        //实例对象
        var dog = new Animal("大黄");
        console.dir(dog);//实例对象
        console.dir(Animal);//构造函数的名字

        console.log(dog.__proto__.constructor == Person);//false
        console.log(dog.__proto__.constructor == Animal);//true

        //判断这个是不是这种数据类型
        console.log(dog.constructor==Animal);
        console.log(dog instanceof Person);
     */

    //总结：
    /**
     * 实例对象和构造函数之间的关系
     * 1.实例对象是通过 构造函数来创建的----创建的构成叫实例化
     * 2.如何判断对象是不是这个数据类型
     *   1）通过构造器的方式实例对象，构造器==构造函数名字
     *   2）对象instanceof构造函数名字
     *   尽可能使用 第二种方式来识别，为什么？原型讲完就明白了
     *
     *
     */
    /*=============================原型引入==================================*/
    //数据共享，节省内存空间，作用之一
    /*
    function Person(name,age) {
        this.name = name;
        this.age = age;
        this.eat = function () {
            console.log("吃肉");
        }
    }
    var per1 = new Person("小白",20);
    var per2 = new Person("小黑",22);
    per1.eat();
    per2.eat();
    //不是同一个方法
    console.log(per1.eat == per2.eat);//false,这两个不是同一个对象，也不是调用同一个方法

    console.dir(per1);
    console.log(per2);
*/

    /*
    function myEat() {
        console.log("吃肉");
    }

    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.eat = myEat;
    }

    var per1 = new Person("小白", 20);
    var per2 = new Person("小黑", 22);
    per1.eat();
    per2.eat();

    console.log(per1.eat == per2.eat);//true

      //实例对象中根本没有eat方法，但是能够使用，这是为什么呢？
    //window是对象
    //document是属性，document也是一个对象
    //write()是方法
    //window.document.write("哈哈");
    //对象.style.color=值;

    */

    /**
     *  原型？
     *  实例对象中有__proto__这个属性，叫原型，也是一个对象，这个属性是给浏览器使用的，不是标准属性
     *  构造函数中有prototype这个属性，叫做原型，也是一个对象,这个属性，是给程序员用的，是标准的属性----》prototype---》可以叫做原型对象
     *  实例对象的__proto__和构造函数中的prototype相等 ---》true
     *  有因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype
     *  实例对象的__proto__指向了构造函数的原型对象prototype
     *
     *
     */

    /*=======================================体会面向过程和面向对象思想编程============================================*/
    /*

        <style>
        #dv {
            width: 200px;
            height: 300px;
            background-color: red;
        }
    </style>

</head>
<body>
<input type="button" value="显示效果" id="btn">
<div id="dv"></div>

    //点击按钮，改变div的背景颜色

    //面向过程
    // my$("btn").onclick = function () {
    //     my$("dv").style.backgroundColor = "yellow";
    // };

       // function Person() {
    //     this.sayHi = function () {
    //         console.log(this);
    //     };
    // }
    // var per  = new Person();
    // per.sayHi();


     */

    /*    //面向对象写法：---初级
    //按钮是一个对象，div是一个对象，颜色是一个属性
    function ChangeStyle(btnId, dvId, color) {
        this.btnObj = my$(btnId);//按钮对象
        this.dvObj = my$(dvId);//div的对象
        this.color = color;//颜色
    }

    //数据共享来改变背景颜色
    ChangeStyle.prototype.init = function () {
        //console.log(this);//就是实例对象--当前对象
        var that = this;
        this.btnObj.onclick = function () {
            that.dvObj.style.backgroundColor = that.color;
        }
    };

    //实例化对象
    var cs = new ChangeStyle("btn", "dv", "yellow");
    cs.init();


    //❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️
      //面向对象写法：---高级
    function ChangeStyle(btnObj, dvObj, json) {
        this.btnObj = btnObj;
        this.dvObj = dvObj;
        this.json = json;
    }
    ChangeStyle.prototype.init = function () {
        //点击按钮，改变div对个样式属性
        var that = this;
        this.btnObj.onclick = function () {//按钮
            for (var key in that.json){
                that.dvObj.style[key] = that.json[key];
            }
        }
    };
    //实例化对象
    var json = {"width":"500px","height":"800px","backgroundColor":"yellow"};
    var cs = new ChangeStyle(my$("btn"),my$("dv"),json);
    cs.init();//调用方法

*/

    /*============================复习原型==============================*/
    /*
       //构造函数
       function Person(name,age) {
           this.name = name;
           this.age = age;
       }
       //通过原型增加方法
        Person.prototype.sayHi = function () {
            console.log("hey");
        };
        var per = new Person("小明",20);
        console.dir(per);
        console.dir(Person);

        var per2 = new Person("女",20);
        console.log(per.sayHi == per2.sayHi);//true

        //实例对象中，有两个属性（这两个属性是通过构造函数来获取的），__proto__这个属性
        //构造函数中并没有sex和age的两个属性
     */

    /**
     * 实例对象中有个属性__proto__，也是对象，叫原型，不是标准的属性，浏览器使用的
     * 构造函数中有一个属性，prototype,也是对象，叫原型，程序员用的
     * 原型----》__proto__或者是prototype，都是原型对象
     * 原型的作用：共享数据，节省内存空间
     *
     */

    /*============================构造函数和实例对象和原型对象的关系================================*/

    /*


        //荣光构造函数实例对象，并且初始化
        var arr = new Array(10,20,30,40);
        //var per = new Person("小明",20,"男");
        //join是方法，实例对象调用的方法
        arr.join("|");
        console.log(arr);
        //join方法在实例对象__proto__原型中
         console.log(arr.__proto__ == Array.prototype);//true

        //构造函数
        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }

        //通过构造函数的原型增加一个方法
        Person.prototype.eat = function () {
            console.log("吃饭");
        };
        var per = new Person(20,"男");
        per.eat();

        //构造函数和原型对象和实例对象的关系
        console.dir(Person);
        console.dir(per);
     */
    /**
     * 1.通过构造函数创建实例对象
     * 2.原型在构造函数里面
     * 3.实例对象可以调用方法
     */


    /*======================总结三者之间的关系=============================*/

    //总结三种的关系

    /**
     * 构造函数可以实例化对象
     * 构造函数中有一个函数叫prototype，是构造函数的原型对象、
     * 构造函数的原型对象（prototype）中有一个constructor构造器，这个构造器指向的就是自己所在的原型对象所在的构造函数
     * 实例对象的原型对象（__proto__）指向的是该构造的原型对象
     * 构造函数的原型对象（prototype）中的方法是可以被实例对象直接访问
     *
     *
     */
    /*===========================利用原型共享数据======================================*/
    /*

        //什么样的额数据是需要写在原型中？
    //需要共享的数据就可以写在原型中
    //原型的作用之一：数据共享

    //属性需要共享，方法也需要共享，写在原型中
    //不需要共享的带哦你关系，写在构造函数中

    //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //所有学生的身高188，所有的体重都是55
    //所有的学生每天都要写500行代码
    //所有的学生每天都要吃10斤西瓜
    //原型对象
    Student.prototype.height = "188cm";
    Student.prototype.weight = "55kg";
    Student.prototype.coding = function () {
        console.log("敲代码。500行");
    };
    Student.prototype.eat = function () {
        console.log("吃10斤西瓜");
    };

    //实例化对象，并且初始化
    var stu = new Student("小明",20,"男");
    console.dir(Student);
    console.dir(stu);//方法在__proto__中
    stu.coding();
    stu.eat();


     */

    /*===========================原型的简单语法===================================*/
    /*

        //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //简单的原型写法
    Student.prototype = {
        //手动修改构造器的指向
        constructor:Student,
        height:"188cm",
        weight :"55kg",
        study : function () {
            console.log("学习好开心呀");
        },
        eat : function () {
            console.log("吃饭啦");
        }
    };

    var stu  = new Student("小明",20,"男");
    console.dir(Student);//原型对象
    console.dir(stu);//实例对象
    stu.study();
    stu.eat();




     */

    /*==========================原型中的方法是可以相互访问的==============================*/

    /*    function Person(age) {
            this.age = age;
            this.sayHi = function () {
                console.log("hey");
                //打招呼的同时，直接调用吃的方法
                // this.eat();
            };
            this.eat = function () {
                console.log("吃饭");
                this.sayHi();
            };
        }
        //实例化对象。并且初始化
        var per = new Person(20);
        //调用方法

        //per.sayHi();
        per.eat();

        //实例对象的方法是可以相互调用的*/

    /*
        //原型中的方法是可以相互访问的
        function Animal(name,age) {
            this.name = name;
            this.age = age;
        }
        //原型中添加方法
        Animal.prototype.eat = function () {
            console.log("动物吃东西");
            this.play();
        };
        Animal.prototype.play = function () {
            console.log("玩球");
            this.sleep();
        };
        Animal.prototype.sleep = function () {
            console.log("睡觉");
        };

        var dog = new Animal("小汪",20,"男");
        dog.eat();
        //原型对象中的方法，是可以相互调用的
    */

    /*=======================实例对象使用的属性和方法层层的搜索========================================*/
    /*


        function Person(age,sex) {
        this.age = age;//年龄
        this.sex = sex;//性别
        this.eat = function () {
            console.log("构造函数中的吃");
        };
    }
    Person.prototype.sex = "女";
    Person.prototype.eat = function () {
      console.log("原型对象吃大餐");
    };
    var per  = new Person(20,"男");
    console.log(per.sex);
    per.eat();
    console.dir(Person);
    console.log(per);
    //先从实例化对象中去找，如果实例对象中部存在，就会在原型中去找


     */

    /*

        实例对象使用的属性或者方法，现在实例中查找，找到了则直接使用，找不到则去实例对象的__proto__指向的原型对象prototype中找，找到了则使用，找不到就会报错

     */


    /*=========================为内置对象的原型对象中添加方法======================================*/
    /*

        //为内置对象增加原型对象方法
    var arr = new Array(10,20,30,40);
    arr.join("|");
    console.log(arr);
    console.dir(arr);

    var str = new String("哦，哈哈");
    str.indexOf("哦");
    console.dir(str);
    //实例中的方法如果没有，去创建改实例对象的构造函数的原型对象中找


    //我们能否为系统的对象的原型中增加方法，相当于改变源码
    //我希望字符串中有一个倒序的这个方法
    String.prototype.myReverse = function () {
        for (var i = this.length-1; i >= 0; i--){
            console.log(this[i])
        }
    };
    var str = "abcdefg";
    str.myReverse();


    //为Array内置对象的原型对象中增加方法
    Array.prototype.mySort = function () {
        for (var i = 0; i <this.length- 1; i++){
            for(var j = 0; j < this.length - 1; j++){
                if (this[j] < this[j+1]){
                    var temp = this[j];
                    this[j] = this [j +1];
                    this[j+1]=temp;
                }
            }
        }
    };
    var arr = [100,20,30,4056,30,20];
    arr.mySort();
    console.log(arr);


    String.prototype.sayHi = function () {
        console.log(this+"哈哈，我又变帅了");
    };
    //字符串就有了打招呼的方法了
    var str2 = "小样";
    str2.sayHi();


     */

    /*========================局部变量变成全局变量==================================*/

    /*

        //该函数的自调用
    //一次性的函数，声明的同时，直接调用了
    //页面加载后，这个自调用函数代码，就执行完了
    // (function (形参) {
    //     var num = 10;
    //     console.log(num);
    // })(实参);
    // console.log(num);//报错


    (function (win) {
        var num = 10;
        //js是一门动态类型的语言，对象没有属性，点了就有了
        win.number = num;
    })(window);

    console.log(number);//10


    //如何把局部变量编程全局
    //把局部变量给window就可以了

     */


    /*=====================产生随机数对象==============================================*/

    /*
   //通过自调用函数产生一个随机数对象，在自调用函数外面，调用改随机数对象方法产生随机数

    (function (window) {
        //产生随机数的构造函数
        function Random() {

        }
        //在原型对象中添加方法
        Random.prototype.getRandom = function (min,max) {
            return Math.floor(Math.random()*(max-min)+min);//0-4
        };

        // var rm = new Random();
        // var num = rm.getRandom();
        // console.log(num);

        window.Random = Random;

    })(window);

    console.log(window.Random);
    var rm =new Random();
    console.log(rm.getRandom(10,50));

     */

    /*======================随机小方块=======================================*/
    /*

            .map {
                width: 800px;
                height: 600px;
                background-color: #d3d3d3;
                position: relative;
            }

        </style>
    </head>
    <body>

    <div class="map">
        <div class="minBox"></div>
    </div>


        //自调用构造函数的方式，分号一定要加上

        //产生随机数的对象
        (function (window) {
            function Random() {

            }

            //在原型对象中增加方法
            Random.prototype.gegRandom = function (min, max) {
                return Math.floor(Math.random() * (max - min) + min);
            };
            //吧局部对象暴露给window顶级对象，就成了全局变量对象
            window.Random =new Random;
        })(window);

        console.log(Random.gegRandom(0,5));
        //产生小方块对象
        (function (window) {
            //选择器的方式来获取元素对象
            var map = document.querySelector(".map");
            //食物的构造函数对象
            function Food(width,height,color) {
                this.width = width || 20;//默认小方块的宽
                this.height = height || 20;
                this.color = color;
                this.x = 0;
                this.y = 0;
                this.element = document.createElement("div");//小方块元素
            }
            //初始化小方块的显示效果及位置---显示地图上面
            Food.prototype.init = function (map) {
                //设置小方块的样式
                var div = this.element;
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height =this.height + "px";
                div.style.backgroundColor = this.color;
                map.appendChild(div);//吧小方块加到map中
                this.render(map);
            };
            //产生随机位置
            Food.prototype.render = function (map) {
                //随机产生横纵坐标
                var x = Random.gegRandom(0,map.offsetWidth/this.width)*this.width;
                var y = Random.gegRandom(0,map.offsetHeight/this.height)*this.height;
                this.x = x;
                this.y = y;
                var div = this.element;
                div.style.left = this.x + "px";
                div.style.top = this.y + "px";

            };

            var fd = new Food(20,20,"green");
            fd.init(map);
        })(window);

     */

    /*============================贪吃蛇=====================================*/
    /*

     <style>
        .map {
            width: 800px;
            height: 600px;
            background-color: #CCC;
            position: relative;
        }
    </style>
</head>
<body>
<!--画出地图,设置样式-->
<div class="map"></div>
<script>


    //自调用函数----食物的
    (function () {
        var elements = [];//用来保存每个小方块食物的
        //食物就是一个对象,有宽,有高,有颜色,有横纵坐标,先定义构造函数,然后创建对象
        function Food(x, y, width, height, color) {
            //横纵坐标
            this.x = x || 0;
            this.y = y || 0;
            //宽和高
            this.width = width || 20;
            this.height = height || 20;
            //背景颜色
            this.color = color || "green";
        }

        //为原型添加初始化的方法(作用：在页面上显示这个食物)
        //因为食物要在地图上显示,所以,需要地图的这个参数(map---就是页面上的.class=map的这个div)
        Food.prototype.init = function (map) {
            //先删除这个小食物
            //外部无法访问的函数
            remove();

            //创建div
            var div = document.createElement("div");
            //把div加到map中
            map.appendChild(div);
            //设置div的样式
            div.style.width = this.width + "px";
            div.style.height = this.height + "px";
            div.style.backgroundColor = this.color;
            //先脱离文档流
            div.style.position = "absolute";
            //随机横纵坐标
            this.x = parseInt(Math.random() * (map.offsetWidth / this.width)) * this.width;
            this.y = parseInt(Math.random() * (map.offsetHeight / this.height)) * this.height;
            div.style.left = this.x + "px";
            div.style.top = this.y + "px";

            //把div加入到数组elements中
            elements.push(div);
        };

        //私有的函数---删除食物的
        function remove() {
            //elements数组中有这个食物
            for (var i = 0; i < elements.length; i++) {
                var ele = elements[i];
                //找到这个子元素的父级元素,然后删除这个子元素
                ele.parentNode.removeChild(ele);
                //再次把elements中的这个子元素也要删除
                elements.splice(i, 1);
            }
        }

        //把Food暴露给Window,外部可以使用
        window.Food = Food;
    }());

    //自调用函数---小蛇
    (function () {
        var elements = [];//存放小蛇的每个身体部分
        //小蛇的构造函数
        function Snake(width, height, direction) {
            //小蛇的每个部分的宽
            this.width = width || 20;
            this.height = height || 20;
            //小蛇的身体
            this.body = [
                {x: 3, y: 2, color: "red"},//头
                {x: 2, y: 2, color: "orange"},//身体
                {x: 1, y: 2, color: "orange"}//身体
            ];
            //方向
            this.direction = direction || "right";
        }

        //为原型添加方法--小蛇初始化的方法
        Snake.prototype.init = function (map) {
            //先删除之前的小蛇
            remove();//===========================================

            //循环遍历创建div
            for (var i = 0; i < this.body.length; i++) {
                //数组中的每个数组元素都是一个对象
                var obj = this.body[i];
                //创建div
                var div = document.createElement("div");
                //把div加入到map地图中
                map.appendChild(div);
                //设置div的样式
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height = this.height + "px";
                //横纵坐标
                div.style.left = obj.x * this.width + "px";
                div.style.top = obj.y * this.height + "px";
                //背景颜色
                div.style.backgroundColor = obj.color;
                //方向暂时不定
                //把div加入到elements数组中----目的是为了删除
                elements.push(div);
            }
        };

        //为原型添加方法---小蛇动起来
        Snake.prototype.move = function (food, map) {
            //改变小蛇的身体的坐标位置
            var i = this.body.length - 1;//2
            for (; i > 0; i--) {
                this.body[i].x = this.body[i - 1].x;
                this.body[i].y = this.body[i - 1].y;
            }
            //判断方向---改变小蛇的头的坐标位置
            switch (this.direction) {
                case "right":
                    this.body[0].x += 1;
                    break;
                case "left":
                    this.body[0].x -= 1;
                    break;
                case "top":
                    this.body[0].y -= 1;
                    break;
                case "bottom":
                    this.body[0].y += 1;
                    break;
            }

            //判断有没有吃到食物
            //小蛇的头的坐标和食物的坐标一致
            var headX=this.body[0].x*this.width;
            var headY=this.body[0].y*this.height;
            //判断小蛇的头的坐标和食物的坐标是否相同
            if(headX==food.x&&headY==food.y){
                //获取小蛇的最后的尾巴
                var last=this.body[this.body.length-1];
                //把最后的蛇尾复制一个,重新的加入到小蛇的body中
                this.body.push({
                    x:last.x,
                    y:last.y,
                    color:last.color
                });
                //把食物删除,重新初始化食物
                food.init(map);
            }
        }
        ;//删除小蛇的私有的函数=============================================================================
        function remove() {
            //删除map中的小蛇的每个div,同时删除elements数组中的每个元素,从蛇尾向蛇头方向删除div
            var i = elements.length - 1;
            for (; i >= 0; i--) {
                //先从当前的子元素中找到该子元素的父级元素,然后再弄死这个子元素
                var ele = elements[i];
                //从map地图上删除这个子元素div
                ele.parentNode.removeChild(ele);
                elements.splice(i, 1);
            }
        }

        //把Snake暴露给window,外部可以访问
        window.Snake = Snake;
    }());

    //自调用函数---游戏对象================================================
    (function () {

        var that = null;//该变量的目的就是为了保存游戏Game的实例对象-------

        //游戏的构造函数
        function Game(map) {
            this.food = new Food();//食物对象
            this.snake = new Snake();//小蛇对象
            this.map = map;//地图
            that = this;//保存当前的实例对象到that变量中-----------------此时that就是this
        }

        //初始化游戏-----可以设置小蛇和食物显示出来
        Game.prototype.init = function () {
            //初始化游戏
            //食物初始化
            this.food.init(this.map);
            //小蛇初始化
            this.snake.init(this.map);
            //调用自动移动小蛇的方法========================||调用了小蛇自动移动的方法
            this.runSnake(this.food, this.map);
            //调用按键的方法
            this.bindKey();//========================================
        };

        //添加原型方法---设置小蛇可以自动的跑起来
        Game.prototype.runSnake = function (food, map) {

            //自动的去移动
            var timeId = setInterval(function () {
                //此时的this是window
                //移动小蛇
                this.snake.move(food, map);
                //初始化小蛇
                this.snake.init(map);
                //横坐标的最大值
                var maxX = map.offsetWidth / this.snake.width;
                //纵坐标的最大值
                var maxY = map.offsetHeight / this.snake.height;
                //小蛇的头的坐标
                var headX = this.snake.body[0].x;
                var headY = this.snake.body[0].y;
                //横坐标
                if (headX < 0 || headX >= maxX) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
                //纵坐标
                if (headY < 0 || headY >= maxY) {
                    //撞墙了,停止定时器
                    clearInterval(timeId);
                    alert("游戏结束");
                }
            }.bind(that), 150);
        };

        //添加原型方法---设置用户按键,改变小蛇移动的方向
        Game.prototype.bindKey=function () {

            //获取用户的按键,改变小蛇的方向
            document.addEventListener("keydown",function (e) {
                //这里的this应该是触发keydown的事件的对象---document,
                //所以,这里的this就是document
                //获取按键的值
                switch (e.keyCode){
                    case 37:this.snake.direction="left";break;
                    case 38:this.snake.direction="top";break;
                    case 39:this.snake.direction="right";break;
                    case 40:this.snake.direction="bottom";break;
                }
            }.bind(that),false);
        };

        //把Game暴露给window,外部就可以访问Game对象了
        window.Game = Game;
    }());



    //初始化游戏对象
    var gm = new Game(document.querySelector(".map"));

    //初始化游戏---开始游戏
    gm.init();


    //外部测试代码
    //  var fd = new Food();
    //  fd.init(document.querySelector(".map"));
    //  //创建小蛇
    //  var snake = new Snake();
    //  snake.init(document.querySelector(".map"));//先在地图上看到小蛇
    //
    //
    //
    //  setInterval(function () {
    //    snake.move(fd, document.querySelector(".map"));
    //    snake.init(document.querySelector(".map"));
    //  }, 150);


    //  snake.move(fd, document.querySelector(".map"));//走一步
    //  snake.init(document.querySelector(".map"));//初始化---重新画一条小蛇(先删除之前的小蛇,把现在的小蛇显示出来)

    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));
    //
    //  snake.move(fd, document.querySelector(".map"));
    //  snake.init(document.querySelector(".map"));


    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //  fd.init(document.querySelector(".map"));
    //console.log(fd.x+"====>"+fd.y);

    //console.log(fd.width);



   */

/*=======================原型以及原型链============================*/
    /*

        //使用对象---》使用对象中的数学和对象中的方法，使用对象就先要有构造函数
    //构造函数
    // function Person(name,age) {
    //     //属性
    //     this.name = name;
    //     this.age = age;
    //     this.sayHi = function () {
    //         console.log("您好，你真帅");
    //     };
    // }
    // //实例化对象，并且初始化
    // for (var  i = 0; i < 100; i++){
    //     var per = new Person("小明",20);
    //     per.sayHi();
    // }

    function Person(name,age) {
        //属性
        this.name = name;
        this.age = age;
        //在构造函数中的方法
        this.eat = function () {
          console.log("吃");
        };
        this.sayHi = function () {
            console.log("您好，你真帅");
        };
    }
    //增加共享的属性和方法
    Person.prototype.sex = "男";
    //增加共享的方法
    Person.prototype.sayHi = function () {
        console.log("您好厊");
    };
    //如果想要使用一些属性和方法，并且熟悉的值在每个对象中都是一样的，方法在每个对象中的操作也都是一样的，那么，为了我共享数据，节省空间，是可以把属性和方法通过原型的方法进行复制
    var per = new Person("小明",20);
    per.sayHi();

    console.dir(per);//实例对象的结构
    console.dir(Person);//构造函数的结构

    //实例对象的原型__proto__和构造函数的原型prototype指向是相同的

    //实例对象中的__proto__原型指向是构造函数中的原型prototype
    console.log(per.__proto__ == Person.prototype);
    //实例对象中__proto__是原型，浏览器中使用的，
    //构造函数中的prototype原型，是程序员用的



     */

    /*=========================原型的指向是否可以改变=====================================*/
    /*

        //构造函数中的this就是实例对象
    //原型对象中方法中的this就是这个实例对象
    // function Person(age) {
    //     this.age = age;
    //     console.log(this);
    // }
    // Person.prototype.eat = function () {
    //     console.log(this);
    //     console.log("您吃饭了么");
    // };
    // var per  = new Person(10);
    // per.eat();
    // console.log(per);


   //  function Student(age) {
   //      this.age = age;
   //      console.log(this);
   //  }
   //  Student.prototype.study = function () {
   //      console.log("学习");
   //  };
   //  Student.prototype = {
   //      eat:function () {
   //          console.log("好吃");
   //      }
   //  };
   // var stu = new Student();
   // stu.eat();


    //这是人的构造函数
    function Person(age) {
        this.age = 10;
        console.log(this);
    }
    //人的饿原型对象方法
    Person.prototype.eat = function () {
        console.log("吃饭🍚");
    };
    //学生的构造函数
    function Student(){
    }
    Student.prototype.sayHi = function(){
      console.log("嗨喽，我很帅的");
    };
    //学生的原型，指向了一个人的实例对象
    Student.prototype = new Person(10);
    var stu = new Student();
    stu.eat();
    //stu.sayHi();

    //原型指向可以改变
    //实例对象的原型__proto__指向是改对象所在的构造函数的原型对象
    //构造函数的原型对象（prrototype）指向如果改变了，实例对象的原型(__proto__)指向也会改变
    //原型的指向是可以改变的
    //实例对象和原型对象之间的关系是通过__proto__原型来联系起来的，这个关系就是原型链

     */

    /*=======================原型最终指向了哪里=======================================================*/

</script>
</html>