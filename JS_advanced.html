<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <link rel="stylesheet" href="">
</head>
<body>

</body>
<script type="text/javascript">
    /*==================================创建对象的三种方式===================================*/
    /*

       //对象：特值的某个事物，具有属性和方法（一组无序的属性的集合）
        //特征---》属性
        //行为---》方法
        //小汪--》姓名,性别，年龄，吃，睡觉，玩

        //创建对象三种方式：
    //    1.字面量的
    //    2.调用系统的构造函数
    //    3.自定义构造函数方式


        //字面量
        var per1 = {
           name:"xixi",
           age:20,
            sex:"男",
             eat:function () {
                 console.log("吃饭");
             },
            readBook:function () {
                console.log("散文诗歌");
            }
        };

        //调用系统函数的构造函数
        var per2 = new Object();
        per2.name = "haha";
        per2.age = 18;
        per2.sex = function () {
            console.log("吃榴莲")
        };
        per2.play = function () {
            console.log("真好玩")
        };
        function Person(){

        }
        //console.log(per2 instanceof Person)
        console.log(per2 instanceof Object);


    //自定义构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;

            this.play = function () {
                console.log("好玩");
            };
        }
        var per =  new Person("汪程序员",19,"女");
        console.log(per instanceof Person);
        console.log(per);
     */

    /*==================================自定义构造函数创建对象做的事情================================================*/
    /*


        function Person(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.play = function () {
            console.log("跑步");
        };
    }
    //创建对象---》实例化一个对象的同时对属性进行初始化
    var per = new Person("小汪",18,"男");
    console.log(per);

*/
    /*
    * 1.开辟空间存储对象
    * 2.把this设置当前的对象
    * 3.设置属性和方法的值
    * 4.把this对象返回
    * */
    /*============================工厂模式=====================================*/
    /*

        // 工厂模式创建对象
    function createObject(name,age) {
        var  obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.sayHi = function () {
            console.log("你好");
        };
        return obj;
    }

    var per = createObject("小汪",19);
    console.log(per);
     */


    /*
    *  自定义构造函数与工厂模式
    *  共同点：都是函数，都可以创建对象，都可以传入参数
    *
    *  工厂模式：函数名是小写,
    *           有new，有返回值
    *           new之后对象是当前的对象
    *           直接调用函数就可以创建对象
    *
    *
    *  自定义构造函数：函数名首字母是大写的，
    *               没有new，没有返回值
    *               this是当前的对象
    *               通过new的方式创建对象的
    *
    *
    * */


    /*=======================构造函数和实例对象之间的关系=======================================*/
    /*

       //面向对象的思想是------抽象的过程----实例化的过程
        //我这个人：姓名，年龄，性别，吃饭，打招呼，睡觉。。。
        //自定义构造函数---实例化对象
        //这是构造函数
        function Person(name,age,sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.sayHi = function () {
                console.log("hello");
            };
            this.sleep = function () {
                console.log("sleep")
            };
            this.eat = function () {
                console.log("吃");
            }
        }//构造函数end


        //构造函数---》创建对象
        var per = new Person("汪洋",28,"男");
        per.eat();
        //实例对象是通过构造函数来创建
        //实例对象会指向自己的构造函数（暂时理解，是错误的）


        console.dir(per);//把这个对象的结构显示出来
        console.dir(Person);
        //实例对象的构造器是指向Person的，结构是true，所以，这个实例对象per就是通过Person来创建的
        console.log(per.constructor==Person);//true   //实例对象的构造器（构造函数）
        console.log(per.__proto__.constructor==Person);//true
        console.log(per.__proto__.constructor == Person.prototype.constructor);//true

        //构造函数
        function Animal(name) {
            this.name = name;
        }
        //实例对象
        var dog = new Animal("大黄");
        console.dir(dog);//实例对象
        console.dir(Animal);//构造函数的名字

        console.log(dog.__proto__.constructor == Person);//false
        console.log(dog.__proto__.constructor == Animal);//true

        //判断这个是不是这种数据类型
        console.log(dog.constructor==Animal);
        console.log(dog instanceof Person);
     */

    //总结：
    /**
     * 实例对象和构造函数之间的关系
     * 1.实例对象是通过 构造函数来创建的----创建的构成叫实例化
     * 2.如何判断对象是不是这个数据类型
     *   1）通过构造器的方式实例对象，构造器==构造函数名字
     *   2）对象instanceof构造函数名字
     *   尽可能使用 第二种方式来识别，为什么？原型讲完就明白了
     *
     *
     */
    /*=============================原型引入==================================*/
    //数据共享，节省内存空间，作用之一
    /*
    function Person(name,age) {
        this.name = name;
        this.age = age;
        this.eat = function () {
            console.log("吃肉");
        }
    }
    var per1 = new Person("小白",20);
    var per2 = new Person("小黑",22);
    per1.eat();
    per2.eat();
    //不是同一个方法
    console.log(per1.eat == per2.eat);//false,这两个不是同一个对象，也不是调用同一个方法

    console.dir(per1);
    console.log(per2);
*/

    /*
    function myEat() {
        console.log("吃肉");
    }

    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.eat = myEat;
    }

    var per1 = new Person("小白", 20);
    var per2 = new Person("小黑", 22);
    per1.eat();
    per2.eat();

    console.log(per1.eat == per2.eat);//true

      //实例对象中根本没有eat方法，但是能够使用，这是为什么呢？
    //window是对象
    //document是属性，document也是一个对象
    //write()是方法
    //window.document.write("哈哈");
    //对象.style.color=值;

    */

    /**
     *  原型？
     *  实例对象中有__proto__这个属性，叫原型，也是一个对象，这个属性是给浏览器使用的，不是标准属性
     *  构造函数中有prototype这个属性，叫做原型，也是一个对象,这个属性，是给程序员用的，是标准的属性----》prototype---》可以叫做原型对象
     *  实例对象的__proto__和构造函数中的prototype相等 ---》true
     *  有因为实例对象是通过构造函数来创建的，构造函数中有原型对象prototype
     *  实例对象的__proto__指向了构造函数的原型对象prototype
     *
     *
     */

    /*=======================================体会面向过程和面向对象思想编程============================================*/
    /*

        <style>
        #dv {
            width: 200px;
            height: 300px;
            background-color: red;
        }
    </style>

</head>
<body>
<input type="button" value="显示效果" id="btn">
<div id="dv"></div>

    //点击按钮，改变div的背景颜色

    //面向过程
    // my$("btn").onclick = function () {
    //     my$("dv").style.backgroundColor = "yellow";
    // };

       // function Person() {
    //     this.sayHi = function () {
    //         console.log(this);
    //     };
    // }
    // var per  = new Person();
    // per.sayHi();


     */

    /*    //面向对象写法：---初级
    //按钮是一个对象，div是一个对象，颜色是一个属性
    function ChangeStyle(btnId, dvId, color) {
        this.btnObj = my$(btnId);//按钮对象
        this.dvObj = my$(dvId);//div的对象
        this.color = color;//颜色
    }

    //数据共享来改变背景颜色
    ChangeStyle.prototype.init = function () {
        //console.log(this);//就是实例对象--当前对象
        var that = this;
        this.btnObj.onclick = function () {
            that.dvObj.style.backgroundColor = that.color;
        }
    };

    //实例化对象
    var cs = new ChangeStyle("btn", "dv", "yellow");
    cs.init();


    //❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️
      //面向对象写法：---高级
    function ChangeStyle(btnObj, dvObj, json) {
        this.btnObj = btnObj;
        this.dvObj = dvObj;
        this.json = json;
    }
    ChangeStyle.prototype.init = function () {
        //点击按钮，改变div对个样式属性
        var that = this;
        this.btnObj.onclick = function () {//按钮
            for (var key in that.json){
                that.dvObj.style[key] = that.json[key];
            }
        }
    };
    //实例化对象
    var json = {"width":"500px","height":"800px","backgroundColor":"yellow"};
    var cs = new ChangeStyle(my$("btn"),my$("dv"),json);
    cs.init();//调用方法

*/

    /*============================复习原型==============================*/
    /*
       //构造函数
       function Person(name,age) {
           this.name = name;
           this.age = age;
       }
       //通过原型增加方法
        Person.prototype.sayHi = function () {
            console.log("hey");
        };
        var per = new Person("小明",20);
        console.dir(per);
        console.dir(Person);

        var per2 = new Person("女",20);
        console.log(per.sayHi == per2.sayHi);//true

        //实例对象中，有两个属性（这两个属性是通过构造函数来获取的），__proto__这个属性
        //构造函数中并没有sex和age的两个属性
     */

    /**
     * 实例对象中有个属性__proto__，也是对象，叫原型，不是标准的属性，浏览器使用的
     * 构造函数中有一个属性，prototype,也是对象，叫原型，程序员用的
     * 原型----》__proto__或者是prototype，都是原型对象
     * 原型的作用：共享数据，节省内存空间
     *
     */

    /*============================构造函数和实例对象和原型对象的关系================================*/

    /*


        //荣光构造函数实例对象，并且初始化
        var arr = new Array(10,20,30,40);
        //var per = new Person("小明",20,"男");
        //join是方法，实例对象调用的方法
        arr.join("|");
        console.log(arr);
        //join方法在实例对象__proto__原型中
         console.log(arr.__proto__ == Array.prototype);//true

        //构造函数
        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }

        //通过构造函数的原型增加一个方法
        Person.prototype.eat = function () {
            console.log("吃饭");
        };
        var per = new Person(20,"男");
        per.eat();

        //构造函数和原型对象和实例对象的关系
        console.dir(Person);
        console.dir(per);
     */
    /**
     * 1.通过构造函数创建实例对象
     * 2.原型在构造函数里面
     * 3.实例对象可以调用方法
     */


    /*======================总结三者之间的关系=============================*/

    //总结三种的关系

    /**
     * 构造函数可以实例化对象
     * 构造函数中有一个函数叫prototype，是构造函数的原型对象、
     * 构造函数的原型对象（prototype）中有一个constructor构造器，这个构造器指向的就是自己所在的原型对象所在的构造函数
     * 实例对象的原型对象（__proto__）指向的是该构造的原型对象
     * 构造函数的原型对象（prototype）中的方法是可以被实例对象直接访问
     *
     *
     */
    /*===========================利用原型共享数据======================================*/
    /*

        //什么样的额数据是需要写在原型中？
    //需要共享的数据就可以写在原型中
    //原型的作用之一：数据共享

    //属性需要共享，方法也需要共享，写在原型中
    //不需要共享的带哦你关系，写在构造函数中

    //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //所有学生的身高188，所有的体重都是55
    //所有的学生每天都要写500行代码
    //所有的学生每天都要吃10斤西瓜
    //原型对象
    Student.prototype.height = "188cm";
    Student.prototype.weight = "55kg";
    Student.prototype.coding = function () {
        console.log("敲代码。500行");
    };
    Student.prototype.eat = function () {
        console.log("吃10斤西瓜");
    };

    //实例化对象，并且初始化
    var stu = new Student("小明",20,"男");
    console.dir(Student);
    console.dir(stu);//方法在__proto__中
    stu.coding();
    stu.eat();


     */

    /*===========================原型的简单语法===================================*/
    /*

        //构造函数
    function Student(name,age,sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    //简单的原型写法
    Student.prototype = {
        //手动修改构造器的指向
        constructor:Student,
        height:"188cm",
        weight :"55kg",
        study : function () {
            console.log("学习好开心呀");
        },
        eat : function () {
            console.log("吃饭啦");
        }
    };

    var stu  = new Student("小明",20,"男");
    console.dir(Student);//原型对象
    console.dir(stu);//实例对象
    stu.study();
    stu.eat();




     */

    /*==========================原型中的方法是可以相互访问的==============================*/

    /*    function Person(age) {
            this.age = age;
            this.sayHi = function () {
                console.log("hey");
                //打招呼的同时，直接调用吃的方法
                // this.eat();
            };
            this.eat = function () {
                console.log("吃饭");
                this.sayHi();
            };
        }
        //实例化对象。并且初始化
        var per = new Person(20);
        //调用方法

        //per.sayHi();
        per.eat();

        //实例对象的方法是可以相互调用的*/

    /*
        //原型中的方法是可以相互访问的
        function Animal(name,age) {
            this.name = name;
            this.age = age;
        }
        //原型中添加方法
        Animal.prototype.eat = function () {
            console.log("动物吃东西");
            this.play();
        };
        Animal.prototype.play = function () {
            console.log("玩球");
            this.sleep();
        };
        Animal.prototype.sleep = function () {
            console.log("睡觉");
        };

        var dog = new Animal("小汪",20,"男");
        dog.eat();
        //原型对象中的方法，是可以相互调用的
    */

    /*=======================实例对象使用的属性和方法层层的搜索========================================*/
    /*


        function Person(age,sex) {
        this.age = age;//年龄
        this.sex = sex;//性别
        this.eat = function () {
            console.log("构造函数中的吃");
        };
    }
    Person.prototype.sex = "女";
    Person.prototype.eat = function () {
      console.log("原型对象吃大餐");
    };
    var per  = new Person(20,"男");
    console.log(per.sex);
    per.eat();
    console.dir(Person);
    console.log(per);
    //先从实例化对象中去找，如果实例对象中部存在，就会在原型中去找


     */

    /*

        实例对象使用的属性或者方法，现在实例中查找，找到了则直接使用，找不到则去实例对象的__proto__指向的原型对象prototype中找，找到了则使用，找不到就会报错

     */


    /*=========================为内置对象的原型对象中添加方法======================================*/
    /*

        //为内置对象增加原型对象方法
    var arr = new Array(10,20,30,40);
    arr.join("|");
    console.log(arr);
    console.dir(arr);

    var str = new String("哦，哈哈");
    str.indexOf("哦");
    console.dir(str);
    //实例中的方法如果没有，去创建改实例对象的构造函数的原型对象中找


    //我们能否为系统的对象的原型中增加方法，相当于改变源码
    //我希望字符串中有一个倒序的这个方法
    String.prototype.myReverse = function () {
        for (var i = this.length-1; i >= 0; i--){
            console.log(this[i])
        }
    };
    var str = "abcdefg";
    str.myReverse();


    //为Array内置对象的原型对象中增加方法
    Array.prototype.mySort = function () {
        for (var i = 0; i <this.length- 1; i++){
            for(var j = 0; j < this.length - 1; j++){
                if (this[j] < this[j+1]){
                    var temp = this[j];
                    this[j] = this [j +1];
                    this[j+1]=temp;
                }
            }
        }
    };
    var arr = [100,20,30,4056,30,20];
    arr.mySort();
    console.log(arr);


    String.prototype.sayHi = function () {
        console.log(this+"哈哈，我又变帅了");
    };
    //字符串就有了打招呼的方法了
    var str2 = "小样";
    str2.sayHi();


     */

    /*========================局部变量变成全局变量==================================*/

    /*

        //该函数的自调用
    //一次性的函数，声明的同时，直接调用了
    //页面加载后，这个自调用函数代码，就执行完了
    // (function (形参) {
    //     var num = 10;
    //     console.log(num);
    // })(实参);
    // console.log(num);//报错


    (function (win) {
        var num = 10;
        //js是一门动态类型的语言，对象没有属性，点了就有了
        win.number = num;
    })(window);

    console.log(number);//10


    //如何把局部变量编程全局
    //把局部变量给window就可以了

     */


    /*=====================产生随机数对象==============================================*/

    /*
   //通过自调用函数产生一个随机数对象，在自调用函数外面，调用改随机数对象方法产生随机数

    (function (window) {
        //产生随机数的构造函数
        function Random() {

        }
        //在原型对象中添加方法
        Random.prototype.getRandom = function (min,max) {
            return Math.floor(Math.random()*(max-min)+min);//0-4
        };

        // var rm = new Random();
        // var num = rm.getRandom();
        // console.log(num);

        window.Random = Random;

    })(window);

    console.log(window.Random);
    var rm =new Random();
    console.log(rm.getRandom(10,50));

     */

    /*======================随机小方块=======================================*/
    /*

            .map {
                width: 800px;
                height: 600px;
                background-color: #d3d3d3;
                position: relative;
            }

        </style>
    </head>
    <body>

    <div class="map">
        <div class="minBox"></div>
    </div>


        //自调用构造函数的方式，分号一定要加上

        //产生随机数的对象
        (function (window) {
            function Random() {

            }

            //在原型对象中增加方法
            Random.prototype.gegRandom = function (min, max) {
                return Math.floor(Math.random() * (max - min) + min);
            };
            //吧局部对象暴露给window顶级对象，就成了全局变量对象
            window.Random =new Random;
        })(window);

        console.log(Random.gegRandom(0,5));
        //产生小方块对象
        (function (window) {
            //选择器的方式来获取元素对象
            var map = document.querySelector(".map");
            //食物的构造函数对象
            function Food(width,height,color) {
                this.width = width || 20;//默认小方块的宽
                this.height = height || 20;
                this.color = color;
                this.x = 0;
                this.y = 0;
                this.element = document.createElement("div");//小方块元素
            }
            //初始化小方块的显示效果及位置---显示地图上面
            Food.prototype.init = function (map) {
                //设置小方块的样式
                var div = this.element;
                div.style.position = "absolute";
                div.style.width = this.width + "px";
                div.style.height =this.height + "px";
                div.style.backgroundColor = this.color;
                map.appendChild(div);//吧小方块加到map中
                this.render(map);
            };
            //产生随机位置
            Food.prototype.render = function (map) {
                //随机产生横纵坐标
                var x = Random.gegRandom(0,map.offsetWidth/this.width)*this.width;
                var y = Random.gegRandom(0,map.offsetHeight/this.height)*this.height;
                this.x = x;
                this.y = y;
                var div = this.element;
                div.style.left = this.x + "px";
                div.style.top = this.y + "px";

            };

            var fd = new Food(20,20,"green");
            fd.init(map);
        })(window);

     */
</script>
</html>