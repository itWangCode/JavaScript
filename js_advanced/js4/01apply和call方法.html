<!--
    Created by wangyang on 2018-12-22.
    itwangyang@gmail.com
    http://itwangyang.xyz    
-->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no">
    <title>Title</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link rel="stylesheet" href="">

</head>
<body>
<script>
    /*
        // apply和call的使用
        //作用：可以改变this的指向

        function f1(x,y) {
            console.log("结果是："+(x+y)+this);
            return "1000000";
        }
        f1(10,20);//函数的调用

        console.log("===========");
        //此时的f1实际上市当成对象来使用的，对象可以调用方法的
        //apply和call方法也是函数的调用的方式
        // f1.apply();
        // f1.call();
        console.log("===============");
        // f1.apply(null);
        // f1.call(null);

        //apply 和 call方法中如果没有传入参数，或者是传入的是Null,那么调用改方法的函数对象中的this就是默认的window

        f1.apply(null,[100,200]);
        f1.call(null,100,200);

        //apply 和call都可以让函数或者方法来调用，传入参数和函数自己调用的写法不一样，但是效果是一样的
        var result1 =  f1.apply(null,[1200,200]);
        var result2 = f1.call(null,1200,200);
        console.log(result1);
        console.log(result2);

        function f2(x,y) {
            console.log("这个函数window对象的一个方法"+(x+y)+this);//40[object Window]
        }
        window.f2(10,30);

        //obj是一个对象
        var obj = {
            age:10,
            sex:"男",
        };
        window.f2.apply(obj,[10,20]);//30[object Object]
        window.f1.call(obj,10,20);
        console.dir(obj);

        //apply和call可以改变this的指向

        function Person(age,sex) {
            this.age = age;
            this.sex = sex;
        }
        //通过原型添加方法
        Person.prototype.sayHi = function () {
            console.log("你好啊"+this.sex);
            return 1000;
        };
        var per = new Person(10,"男");
        per.sayHi();

        console.log("=======================");
        function Student(name,sex) {
            this.name = name;
            this.sex = sex;
        }
        var stu = new Student("小明","人妖");
        var r1 = per.sayHi.apply(stu,[10,20]);
        var r2 = per.sayHi.call(stu,10,20);
        console.log(r1);
        console.log(r2);

    */

/*    //apply和call都可以改变this的指向
    //函数的调用，改变this的指向
    function f1(x, y) {
        console.log((x + y) + ":===》" + this);
        return "这是函数的返回值";
    }

    //apply和call调用
    var r1 = f1.apply(null, [1, 2]);//此时f1中的this是window
    console.log(r1);

    //call调用
    var r2 = f1.call(null, 1, 2);//此时f1中的this是window
    console.log(r2);

    console.log("===============");
    //改变this的指向
    var obj = {
        sex : "男"
    };
    //本来f1函数是window的，但是传入obj，this就是object的了
    //apply调用
    var r1 = f1.apply(obj, [1, 2]);//此时f1中的this是object
    console.log(r1);

    //call调用
    var r2 = f1.call(obj, 1, 2);//此时f1中的this是object
    console.log(r2);*/


//    方法改变this的指向
    function Person(age) {
        this.age = age;
    }
    Person.prototype.sayHi = function (x,y) {
        console.log((x+y)+":====>"+this.age);//是实例对象
    };
    
    function Student() {
        
    }
    var per = new Person(10);//实例对象
    var stu = new Student();//实例对象
    //sayHi 方法是per实例对象的方法
    per.sayHi.apply(stu,[10,20]);
    per.sayHi.call(stu,10,20);


    //apply 和call的使用方法
    // apply的使用语法：
    // 函数名字.apply(对象,[参数1,参数2,....]);
    // 方法名字.apply(对象,[参数1,参数2,....]);
    //
    //call的使用语法：
    //函数名字.call(对象,参数1,参数2);
    //方法名字.call(对象,参数1,参数2);
    //
    //作用：改变this的指向
    //不用的地方：参数传递的方式是不一样的
    //只要是想使用别的对象的方法，并且希望这个方法是当前对象的，那么就可以使用apply或者是call的方法改变this的指向






</script>
</body>
</html>